[{"id":0,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse Component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront Matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom Container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode Block#\n\n\nBasic Usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow Line Numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap Code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine Highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOuput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use Component","id":"use-component","depth":2,"charIndex":198},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom Container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code Block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic Usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show Line Numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap Code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line Highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1711}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"day01","content":"#\n\n\n一、为什么要学习Vue#\n\n1.前端必备技能\n\n2.岗位多，绝大互联网公司都在使用Vue\n\n3.提高开发效率\n\n4.高薪必备技能（Vue2-Vue3）\n\n\n二、什么是Vue#\n\n概念：Vue (读音 /vjuː/，类似于 view) 是一套 构建用户界面的渐进式框架\n\nVue2官网：https://v2.cn.vuejs.org/\n\n\n1.什么是构建用户界面#\n\n基于数据渲染出用户可以看到的界面\n\n\n\n\n2.什么是渐进式#\n\n所谓渐进式就是循序渐进，不一定非得把Vue中的所有API都学完才能开发Vue，可以学一点开发一点\n\nVue的两种开发方式#\n\n 1. Vue核心包开发\n    \n    场景：局部模块改造\n\n 2. Vue核心包&Vue插件&工程化\n    \n    场景：整站开发\n\n\n3.什么是框架#\n\n所谓框架：就是一套完整的解决方案\n\n举个栗子。\n\n如果把一个完整的项目比喻为一个装修好的房子，那么框架就是一个毛坯房。\n\n我们只需要在“毛坯房”的基础上，增加功能代码即可。\n\n提到框架，不得不提一下库。\n\n * 库，类似工具箱，是一堆方法的集合，比如 axios、lodash、echarts等\n * 框架，是一套完整的解决方案，实现了大部分功能，我们只需要按照一定的规则去编码即可。\n\n下图是 库 和 框架的对比。\n\n\n\n框架的特点：有一套必须让开发者遵守的规则或者约束\n\n咱们学框架就是学习的这些规则 官网\n\n\n总结：什么是Vue？#\n\nVue是什么：\n\n什么是构建用户界面：\n\n什么是渐进式：\n\n什么是框架：\n\n\n三、创建Vue实例#\n\n我们已经知道了Vue框架可以 基于数据帮助我们渲染出用户界面，那应该怎么做呢？\n\n\n\n比如就上面这个数据，基于提供好的msg 怎么渲染后右侧可展示的数据呢？\n\n核心步骤（4步）：\n\n 1. 准备容器\n 2. 引包（官网） — 开发版本/生产版本\n 3. 创建Vue实例 new Vue()\n 4. 指定配置项，渲染数据\n    1. el:指定挂载点\n    2. data提供数据\n\n\n\n总结：创建Vue实例需要执行哪4步。\n\n\n四、插值表达式 {{}}#\n\n插值表达式是一种Vue的模板语法\n\n我们可以用插值表达式渲染出Vue提供的数据\n\n\n\n\n1.作用：利用表达式进行插值，渲染到页面中#\n\n表达式：是可以被求值的代码，JS引擎会讲其计算出一个结果\n\n以下的情况都是表达式：\n\n\n\n\n2.语法#\n\n插值表达式语法：{{ 表达式 }}\n\n\n\n\n3.错误用法#\n\n\n\n\n4.总结#\n\n1.插值表达式的作用是什么\n\n2.语法是什么\n\n3.插值表达式的注意事项\n\n\n五、响应式特性#\n\n\n1.什么是响应式？#\n\n简单理解就是数据变，视图对应变。\n\n\n2.如何访问 和 修改 data中的数据（响应式演示）#\n\ndata中的数据, 最终会被添加到实例上\n\n① 访问数据： \"实例.属性名\"\n\n② 修改数据： \"实例.属性名\"= \"值\"\n\n\n\n\n3.总结#\n\n 1. 什么是响应式\n 2. 如何访问和修改data中的数据呢\n\n\n六、Vue开发者工具安装#\n\n 1. 通过谷歌应用商店安装（国外网站）\n 2. 极简插件下载（推荐） https://chrome.zzzmh.cn/index\n\n安装步骤：\n\n\n\n安装之后可以F12后看到多一个Vue的调试面板\n\n\n\n\n七、Vue中的常用指令#\n\n概念：指令（Directives）是 Vue 提供的带有 v- 前缀 的 特殊 标签属性。\n\n为啥要学：提高程序员操作 DOM 的效率。\n\nvue 中的指令按照不同的用途可以分为如下 6 大类：\n\n * 内容渲染指令（v-html、v-text）\n * 条件渲染指令（v-show、v-if、v-else、v-else-if）\n * 事件绑定指令（v-on）\n * 属性绑定指令 （v-bind）\n * 双向绑定指令（v-model）\n * 列表渲染指令（v-for）\n\n指令是 vue 开发中最基础、最常用、最简单的知识点。\n\n\n八、内容渲染指令#\n\n内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下2 个：\n\n * v-text（类似innerText）\n\n * * 使用语法：\n     \n     hello\n     \n     ，意思是将 uame 值渲染到 p 标签中\n   * 类似 innerText，使用该语法，会覆盖 p 标签原有内容\n\n * v-html（类似 innerHTML）\n\n * * 使用语法：\n     \n     hello\n     \n     ，意思是将 intro 值渲染到 p 标签中\n   * 类似 innerHTML，使用该语法，会覆盖 p 标签原有内容\n   * 类似 innerHTML，使用该语法，能够将HTML标签的样式呈现出来。\n\n代码演示：\n\n\n\n\n九、条件渲染指令#\n\n条件判断指令，用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是：\n\n 1. v-show\n    \n    1. 作用： 控制元素显示隐藏\n    2. 语法： v-show = \"表达式\" 表达式值为 true 显示， false 隐藏\n    3. 原理： 切换 display:none 控制显示隐藏\n    4. 场景：频繁切换显示隐藏的场景\n    \n    \n\n 2. v-if\n    \n    1. 作用： 控制元素显示隐藏（条件渲染）\n    2. 语法： v-if= \"表达式\" 表达式值 true显示， false 隐藏\n    3. 原理： 基于条件判断，是否创建 或 移除元素节点\n    4. 场景： 要么显示，要么隐藏，不频繁切换的场景\n    \n    \n    \n    示例代码：\n    \n    \n\n 3. v-else 和 v-else-if\n    \n    1. 作用：辅助v-if进行判断渲染\n    2. 语法：v-else v-else-if=\"表达式\"\n    3. 需要紧接着v-if使用\n\n示例代码：\n\n\n\n\n十、事件绑定指令#\n\n使用Vue时，如需为DOM注册事件，及其的简单，语法如下：\n\n * 按钮\n * 按钮\n * 按钮\n * v-on: 简写为 @\n\n 1. 内联语句\n    \n    \n\n 2. 事件处理函数\n    \n    注意：\n    \n    * 事件处理函数应该写到一个跟data同级的配置项（methods）中\n    * methods中的函数内部的this都指向Vue实例\n\n\n\n3.给事件处理函数传参\n\n * 如果不传递任何参数，则方法无需加小括号；methods方法中可以直接使用 e 当做事件对象\n\n * 如果传递了参数，则实参 $event 表示事件对象，固定用法。\n\n\n\n\n十一、属性绑定指令#\n\n 1. **作用：**动态设置html的标签属性 比如：src、url、title\n 2. 语法：**v-bind:**属性名=“表达式”\n 3. **v-bind:**可以简写成 => :\n\n比如，有一个图片，它的 src 属性值，是一个图片地址。这个地址在数据 data 中存储。\n\n则可以这样设置属性值：\n\n * \n * （v-bind可以省略）\n\n\n\n\n十二、小案例-波仔的学习之旅#\n\n需求：默认展示数组中的第一张图片，点击上一页下一页来回切换数组中的图片\n\n实现思路：\n\n1.数组存储图片路径 ['url1','url2','url3'，...]\n\n2.可以准备个下标index 去数组中取图片地址。\n\n3.通过v-bind给src绑定当前的图片地址\n\n4.点击上一页下一页只需要修改下标的值即可\n\n5.当展示第一张的时候，上一页按钮应该隐藏。展示最后一张的时候，下一页按钮应该隐藏\n\n\n\n\n十三、列表渲染指令#\n\nVue 提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。\n\nv-for 指令需要使用 (item, index) in arr 形式的特殊语法，其中：\n\n * item 是数组中的每一项\n * index 是每一项的索引，不需要可以省略\n * arr 是被遍历的数组\n\n此语法也可以遍历对象和数字\n\n\n\n\n十四、小案例-小黑的书架#\n\n需求：\n\n1.根据左侧数据渲染出右侧列表（v-for）\n\n2.点击删除按钮时，应该把当前行从列表中删除（获取当前行的id，利用filter进行过滤）\n\n\n\n准备代码：\n\n\n\n\n十五、v-for中的key#\n\n语法： key=\"唯一值\"\n\n作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。\n\n**为什么加key：**Vue 的默认行为会尝试原地修改元素（就地复用）\n\n实例代码：\n\n\n\n注意：\n\n 1. key 的值只能是字符串 或 数字类型\n 2. key 的值必须具有唯一性\n 3. 推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）\n\n\n十六、双向绑定指令#\n\n所谓双向绑定就是：\n\n 1. 数据改变后，呈现的页面结果会更新\n 2. 页面结果更新后，数据也会随之而变\n\n作用： 给表单元素（input、radio、select）使用，双向绑定数据，可以快速 获取 或 设置 表单元素内容\n\n**语法：**v-model=\"变量\"\n\n**需求：**使用双向绑定实现以下需求\n\n 1. 点击登录按钮获取表单中的内容\n 2. 点击重置按钮清空表单中的内容\n\n\n\n\n\n\n十七、综合案例-小黑记事本#\n\n\n\n功能需求：\n\n 1. 列表渲染\n\n 2. 删除功能\n\n 3. 添加功能\n\n 4. 底部统计 和 清空","routePath":"/vue/day01/day01","lang":"","toc":[{"text":"一、为什么要学习Vue","id":"一为什么要学习vue","depth":2,"charIndex":3},{"text":"二、什么是Vue","id":"二什么是vue","depth":2,"charIndex":81},{"text":"1.什么是构建用户界面","id":"1什么是构建用户界面","depth":3,"charIndex":172},{"text":"2.什么是渐进式","id":"2什么是渐进式","depth":3,"charIndex":207},{"text":"Vue的两种开发方式","id":"vue的两种开发方式","depth":4,"charIndex":268},{"text":"3.什么是框架","id":"3什么是框架","depth":3,"charIndex":354},{"text":"总结：什么是Vue？","id":"总结什么是vue","depth":3,"charIndex":622},{"text":"三、创建Vue实例","id":"三创建vue实例","depth":2,"charIndex":674},{"text":"四、插值表达式 `{{}}`","id":"四插值表达式-","depth":2,"charIndex":-1},{"text":"1.作用：利用表达式进行插值，渲染到页面中","id":"1作用利用表达式进行插值渲染到页面中","depth":3,"charIndex":961},{"text":"2.语法","id":"2语法","depth":3,"charIndex":1031},{"text":"3.错误用法","id":"3错误用法","depth":3,"charIndex":1060},{"text":"4.总结","id":"4总结","depth":3,"charIndex":1072},{"text":"五、响应式特性","id":"五响应式特性","depth":2,"charIndex":1118},{"text":"1.什么是响应式？","id":"1什么是响应式","depth":3,"charIndex":1129},{"text":"2.如何访问 和 修改 data中的数据（响应式演示）","id":"2如何访问-和-修改-data中的数据响应式演示","depth":3,"charIndex":1160},{"text":"3.总结","id":"3总结","depth":3,"charIndex":1256},{"text":"六、Vue开发者工具安装","id":"六vue开发者工具安装","depth":2,"charIndex":1297},{"text":"七、Vue中的常用指令","id":"七vue中的常用指令","depth":2,"charIndex":1416},{"text":"八、内容渲染指令","id":"八内容渲染指令","depth":2,"charIndex":1696},{"text":"九、条件渲染指令","id":"九条件渲染指令","depth":2,"charIndex":2053},{"text":"十、事件绑定指令","id":"十事件绑定指令","depth":2,"charIndex":2562},{"text":"十一、属性绑定指令","id":"十一属性绑定指令","depth":2,"charIndex":2865},{"text":"十二、小案例-波仔的学习之旅","id":"十二小案例-波仔的学习之旅","depth":2,"charIndex":3058},{"text":"十三、列表渲染指令","id":"十三列表渲染指令","depth":2,"charIndex":3279},{"text":"十四、小案例-小黑的书架","id":"十四小案例-小黑的书架","depth":2,"charIndex":3462},{"text":"十五、v-for中的key","id":"十五v-for中的key","depth":2,"charIndex":3565},{"text":"十六、双向绑定指令","id":"十六双向绑定指令","depth":2,"charIndex":3778},{"text":"十七、综合案例-小黑记事本","id":"十七综合案例-小黑记事本","depth":2,"charIndex":3990}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"day02","content":"#\n\n\n一、今日学习目标#\n\n\n1.指令补充#\n\n 1. 指令修饰符\n 2. v-bind对样式增强的操作\n 3. v-model应用于其他表单元素\n\n\n2.computed计算属性#\n\n 1. 基础语法\n 2. 计算属性vs方法\n 3. 计算属性的完整写法\n 4. 成绩案例\n\n\n3.watch侦听器#\n\n 1. 基础写法\n 2. 完整写法\n\n\n4.综合案例 （演示）#\n\n 1. 渲染 / 删除 / 修改数量 / 全选 / 反选 / 统计总价 / 持久化\n\n\n二、指令修饰符#\n\n\n1.什么是指令修饰符？#\n\n所谓指令修饰符就是通过“.”指明一些指令后缀 不同的后缀封装了不同的处理操作 —> 简化代码\n\n\n2.按键修饰符#\n\n * @keyup.enter —>当点击enter键的时候才触发\n\n代码演示：\n\n\n\n\n3.v-model修饰符#\n\n * v-model.trim —>去除首位空格\n * v-model.number —>转数字\n\n\n4.事件修饰符#\n\n * @事件名.stop —> 阻止冒泡\n * @事件名.prevent —>阻止默认行为\n * @事件名.stop.prevent —>可以连用 即阻止事件冒泡也阻止默认行为\n\n\n\n\n三、v-bind对样式控制的增强-操作class#\n\n为了方便开发者进行样式控制， Vue 扩展了 v-bind 的语法，可以针对 class 类名 和 style 行内样式 进行控制 。\n\n\n1.语法#\n\n\n\n\n2.对象语法#\n\n当class动态绑定的是对象时，键就是类名，值就是布尔值，如果值是true，就有这个类，否则没有这个类\n\n\n\n适用场景：一个类名，来回切换\n\n\n3.数组语法#\n\n当class动态绑定的是数组时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表\n\n\n\n使用场景:批量添加或删除类\n\n\n4.代码练习#\n\n\n\n\n四、京东秒杀-tab栏切换导航高亮#\n\n\n1.需求#\n\n当我们点击哪个tab页签时，哪个tab页签就高亮\n\n\n2.准备代码#\n\n\n\n\n3.思路#\n\n1.基于数据，动态渲染tab（v-for）\n\n2.准备一个下标 记录高亮的是哪一个 tab\n\n3.基于下标动态切换class的类名\n\n\n五、v-bind对有样式控制的增强-操作style#\n\n\n1.语法#\n\n\n\n\n2.代码练习#\n\n\n\n\n3.进度条案例#\n\n\n\n\n六、v-model在其他表单元素的使用#\n\n\n1.讲解内容#\n\n常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值\n\n它会根据 控件类型 自动选取 正确的方法 来更新元素\n\n\n\n\n2.代码准备#\n\n\n\n\n七、computed计算属性#\n\n\n1.概念#\n\n基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。\n\n\n2.语法#\n\n 1. 声明在 computed 配置项中，一个计算属性对应一个函数\n 2. 使用起来和普通属性一样使用 {{ 计算属性名}}\n\n\n3.注意#\n\n 1. computed配置项和data配置项是同级的\n 2. computed中的计算属性虽然是函数的写法，但他依然是个属性\n 3. computed中的计算属性不能和data中的属性同名\n 4. 使用computed中的计算属性和使用data中的属性是一样的用法\n 5. computed中计算属性内部的this依然指向的是Vue实例\n\n\n4.案例#\n\n比如我们可以使用计算属性实现下面这个业务场景\n\n\n\n\n5.代码准备#\n\n\n\n\n八、computed计算属性 VS methods方法#\n\n\n1.computed计算属性#\n\n作用：封装了一段对于数据的处理，求得一个结果\n\n语法：\n\n 1. 写在computed配置项中\n 2. 作为属性，直接使用\n    * js中使用计算属性： this.计算属性\n    * 模板中使用计算属性：{{计算属性}}\n\n\n2.methods计算属性#\n\n作用：给Vue实例提供一个方法，调用以处理业务逻辑。\n\n语法：\n\n 1. 写在methods配置项中\n 2. 作为方法调用\n    * js中调用：this.方法名()\n    * 模板中调用 {{方法名()}} 或者 @事件名=“方法名”\n\n\n3.计算属性的优势#\n\n 1. 缓存特性（提升性能）\n    \n    计算属性会对计算出来的结果缓存，再次使用直接读取缓存，\n    \n    依赖项变化了，会自动重新计算 → 并再次缓存\n\n 2. methods没有缓存特性\n\n 3. 通过代码比较\n\n\n\n\n4.总结#\n\n1.computed有缓存特性，methods没有缓存\n\n2.当一个结果依赖其他多个值时，推荐使用计算属性\n\n3.当处理业务逻辑时，推荐使用methods方法，比如事件的处理函数\n\n\n九、计算属性的完整写法#\n\n既然计算属性也是属性，能访问，应该也能修改了？\n\n 1. 计算属性默认的简写，只能读取访问，不能 \"修改\"\n 2. 如果要 \"修改\" → 需要写计算属性的完整写法\n\n\n\n完整写法代码演示\n\n\n\n\n十、综合案例-成绩案例#\n\n\n\n功能描述：\n\n1.渲染功能\n\n2.删除功能\n\n3.添加功能\n\n4.统计总分，求平均分\n\n思路分析：\n\n1.渲染功能 v-for :key v-bind:动态绑定class的样式\n\n2.删除功能 v-on绑定事件， 阻止a标签的默认行为\n\n3.v-model的修饰符 .trim、 .number、 判断数据是否为空后 再添加、添加后清空文本框的数据\n\n4.使用计算属性computed 计算总分和平均分的值\n\n\n十一、watch侦听器（监视器）#\n\n\n1.作用#\n\n监视数据变化，执行一些业务逻辑或异步操作\n\n\n2.语法#\n\n 1. watch同样声明在跟data同级的配置项中\n\n 2. 简单写法： 简单类型数据直接监视\n\n 3. 完整写法：添加额外配置项\n    \n    \n\n\n3.侦听器代码准备#\n\n\n\n\n十二、翻译案例-代码实现#\n\n\n\n\n十三、watch侦听器#\n\n\n1.语法#\n\n完整写法 —>添加额外的配置项\n\n 1. deep:true 对复杂类型进行深度监听\n 2. immdiate:true 初始化 立刻执行一次\n\n\n\n\n2.需求#\n\n\n\n * 当文本框输入的时候 右侧翻译内容要时时变化\n * 当下拉框中的语言发生变化的时候 右侧翻译的内容依然要时时变化\n * 如果文本框中有默认值的话要立即翻译\n\n\n3.代码实现#\n\n\n\n\n4.总结#\n\nwatch侦听器的写法有几种？\n\n1.简单写法\n\n\n\n2.完整写法\n\n\n\n\n十四、综合案例#\n\n购物车案例\n\n\n\n需求说明：\n\n 1. 渲染功能\n 2. 删除功能\n 3. 修改个数\n 4. 全选反选\n 5. 统计 选中的 总价 和 总数量\n 6. 持久化到本地\n\n实现思路：\n\n1.基本渲染： v-for遍历、:class动态绑定样式\n\n2.删除功能 ： v-on 绑定事件，获取当前行的id\n\n3.修改个数 ： v-on绑定事件，获取当前行的id，进行筛选出对应的项然后增加或减少\n\n4.全选反选\n\n 1. 必须所有的小选框都选中，全选按钮才选中 → every\n 2. 如果全选按钮选中，则所有小选框都选中\n 3. 如果全选取消，则所有小选框都取消选中\n\n声明计算属性，判断数组中的每一个checked属性的值，看是否需要全部选\n\n5.统计 选中的 总价 和 总数量 ：通过计算属性来计算选中的总价和总数量\n\n6.持久化到本地： 在数据变化时都要更新下本地存储 watch","routePath":"/vue/day02/day02","lang":"","toc":[{"text":"一、今日学习目标","id":"一今日学习目标","depth":2,"charIndex":3},{"text":"1.指令补充","id":"1指令补充","depth":3,"charIndex":15},{"text":"2.computed计算属性","id":"2computed计算属性","depth":3,"charIndex":76},{"text":"3.watch侦听器","id":"3watch侦听器","depth":3,"charIndex":140},{"text":"4.综合案例 （演示）","id":"4综合案例-演示","depth":3,"charIndex":173},{"text":"二、指令修饰符","id":"二指令修饰符","depth":2,"charIndex":231},{"text":"1.什么是指令修饰符？","id":"1什么是指令修饰符","depth":3,"charIndex":242},{"text":"2.按键修饰符","id":"2按键修饰符","depth":3,"charIndex":305},{"text":"3.v-model修饰符","id":"3v-model修饰符","depth":3,"charIndex":360},{"text":"4.事件修饰符","id":"4事件修饰符","depth":3,"charIndex":426},{"text":"三、v-bind对样式控制的增强-操作class","id":"三v-bind对样式控制的增强-操作class","depth":2,"charIndex":529},{"text":"1.语法","id":"1语法","depth":3,"charIndex":626},{"text":"2.对象语法","id":"2对象语法","depth":3,"charIndex":636},{"text":"3.数组语法","id":"3数组语法","depth":3,"charIndex":717},{"text":"4.代码练习","id":"4代码练习","depth":3,"charIndex":796},{"text":"四、京东秒杀-tab栏切换导航高亮","id":"四京东秒杀-tab栏切换导航高亮","depth":2,"charIndex":808},{"text":"1.需求","id":"1需求","depth":3,"charIndex":829},{"text":"2.准备代码","id":"2准备代码","depth":3,"charIndex":863},{"text":"3.思路","id":"3思路","depth":3,"charIndex":875},{"text":"五、v-bind对有样式控制的增强-操作style","id":"五v-bind对有样式控制的增强-操作style","depth":2,"charIndex":950},{"text":"1.语法","id":"1语法-1","depth":3,"charIndex":979},{"text":"2.代码练习","id":"2代码练习","depth":3,"charIndex":989},{"text":"3.进度条案例","id":"3进度条案例","depth":3,"charIndex":1001},{"text":"六、v-model在其他表单元素的使用","id":"六v-model在其他表单元素的使用","depth":2,"charIndex":1014},{"text":"1.讲解内容","id":"1讲解内容","depth":3,"charIndex":1037},{"text":"2.代码准备","id":"2代码准备","depth":3,"charIndex":1123},{"text":"七、computed计算属性","id":"七computed计算属性","depth":2,"charIndex":1135},{"text":"1.概念","id":"1概念","depth":3,"charIndex":1153},{"text":"2.语法","id":"2语法","depth":3,"charIndex":1196},{"text":"3.注意","id":"3注意","depth":3,"charIndex":1269},{"text":"4.案例","id":"4案例","depth":3,"charIndex":1448},{"text":"5.代码准备","id":"5代码准备","depth":3,"charIndex":1482},{"text":"八、computed计算属性 VS methods方法","id":"八computed计算属性-vs-methods方法","depth":2,"charIndex":1494},{"text":"1.computed计算属性","id":"1computed计算属性","depth":3,"charIndex":1525},{"text":"2.methods计算属性","id":"2methods计算属性","depth":3,"charIndex":1658},{"text":"3.计算属性的优势","id":"3计算属性的优势","depth":3,"charIndex":1797},{"text":"4.总结","id":"4总结","depth":3,"charIndex":1928},{"text":"九、计算属性的完整写法","id":"九计算属性的完整写法","depth":2,"charIndex":2027},{"text":"十、综合案例-成绩案例","id":"十综合案例-成绩案例","depth":2,"charIndex":2139},{"text":"十一、watch侦听器（监视器）","id":"十一watch侦听器监视器","depth":2,"charIndex":2361},{"text":"1.作用","id":"1作用","depth":3,"charIndex":2381},{"text":"2.语法","id":"2语法-1","depth":3,"charIndex":2411},{"text":"3.侦听器代码准备","id":"3侦听器代码准备","depth":3,"charIndex":2497},{"text":"十二、翻译案例-代码实现","id":"十二翻译案例-代码实现","depth":2,"charIndex":2512},{"text":"十三、watch侦听器","id":"十三watch侦听器","depth":2,"charIndex":2530},{"text":"1.语法","id":"1语法-2","depth":3,"charIndex":2545},{"text":"2.需求","id":"2需求","depth":3,"charIndex":2628},{"text":"3.代码实现","id":"3代码实现","depth":3,"charIndex":2719},{"text":"4.总结","id":"4总结-1","depth":3,"charIndex":2731},{"text":"十四、综合案例","id":"十四综合案例","depth":2,"charIndex":2776}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"day03","content":"#\n\n\n一、今日目标#\n\n\n1.生命周期#\n\n 1. 生命周期介绍\n 2. 生命周期的四个阶段\n 3. 生命周期钩子\n 4. 声明周期案例\n\n\n2.综合案例-小黑记账清单#\n\n 1. 列表渲染\n 2. 添加/删除\n 3. 饼图渲染\n\n\n3.工程化开发入门#\n\n 1. 工程化开发和脚手架\n 2. 项目运行流程\n 3. 组件化\n 4. 组件注册\n\n\n4.综合案例-小兔仙首页#\n\n 1. 拆分模块-局部注册\n 2. 结构样式完善\n 3. 拆分组件 – 全局注册\n\n\n二、Vue生命周期#\n\n思考：什么时候可以发送初始化渲染请求？（越早越好）什么时候可以开始操作dom？（至少dom得渲染出来）\n\nVue生命周期：就是一个Vue实例从创建 到 销毁 的整个过程。\n\n生命周期四个阶段：① 创建 ② 挂载 ③ 更新 ④ 销毁\n\n1.创建阶段：创建响应式数据\n\n2.挂载阶段：渲染模板\n\n3.更新阶段：修改数据，更新视图\n\n4.销毁阶段：销毁Vue实例\n\n\n\n\n三、Vue生命周期钩子#\n\nVue生命周期过程中，会自动运行一些函数，被称为【生命周期钩子】→ 让开发者可以在【特定阶段】运行自己的代码\n\n\n\n\n\n\n四、生命周期钩子小案例#\n\n\n1.在created中发送数据#\n\n\n\n\n2.在mounted中获取焦点#\n\n\n\n\n五、案例-小黑记账清单#\n\n\n1.需求图示#\n\n\n\n\n2.需求分析#\n\n1.基本渲染\n\n2.添加功能\n\n3.删除功能\n\n4.饼图渲染\n\n\n3.思路分析#\n\n1.基本渲染\n\n * 立刻发送请求获取数据 created\n * 拿到数据，存到data的响应式数据中\n * 结合数据，进行渲染 v-for\n * 消费统计 —> 计算属性\n\n2.添加功能\n\n * 收集表单数据 v-model，使用指令修饰符处理数据\n * 给添加按钮注册点击事件，对输入的内容做非空判断，发送请求\n * 请求成功后，对文本框内容进行清空\n * 重新渲染列表\n\n3.删除功能\n\n * 注册点击事件，获取当前行的id\n * 根据id发送删除请求\n * 需要重新渲染\n\n4.饼图渲染\n\n * 初始化一个饼图 echarts.init(dom) mounted钩子中渲染\n * 根据数据试试更新饼图 echarts.setOptions({...})\n\n\n4.代码准备#\n\n\n\n\n六、工程化开发和脚手架#\n\n\n1.开发Vue的两种方式#\n\n * 核心包传统开发模式：基于html / css / js 文件，直接引入核心包，开发 Vue。\n * 工程化开发模式：基于构建工具（例如：webpack）的环境中开发Vue。\n\n\n\n工程化开发模式优点：\n\n提高编码效率，比如使用JS新语法、Less/Sass、Typescript等通过webpack都可以编译成浏览器识别的ES3/ES5/CSS等\n\n工程化开发模式问题：\n\n * webpack配置不简单\n * 雷同的基础配置\n * 缺乏统一的标准\n\n为了解决以上问题，所以我们需要一个工具，生成标准化的配置\n\n\n2.脚手架Vue CLI#\n\n基本介绍#\n\nVue CLI 是Vue官方提供的一个全局命令工具\n\n可以帮助我们快速创建一个开发Vue项目的标准化基础架子。【集成了webpack配置】\n\n好处#\n\n 1. 开箱即用，零配置\n 2. 内置babel等工具\n 3. 标准化的webpack配置\n\n使用步骤#\n\n 1. 全局安装（只需安装一次即可） yarn global add @vue/cli 或者 npm i @vue/cli -g\n 2. 查看vue/cli版本： vue --version\n 3. 创建项目架子：vue create project-name(项目名不能使用中文)\n 4. 启动项目：yarn serve 或者 npm run serve(命令不固定，找package.json)\n\n\n七、项目目录介绍和运行流程#\n\n\n1.项目目录介绍#\n\n\n\n虽然脚手架中的文件有很多，目前咱们只需人事三个文件即可\n\n 1. main.js 入口文件\n 2. App.vue App根组件\n 3. index.html 模板文件\n\n\n2.运行流程#\n\n\n\n\n八、组件化开发#\n\n组件化：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为。\n\n好处：便于维护，利于复用 → 提升开发效率。\n\n组件分类：普通组件、根组件。\n\n比如：下面这个页面，可以把所有的代码都写在一个页面中，但是这样显得代码比较混乱，难易维护。咱们可以按模块进行组件划分\n\n\n\n总结：\n\n组件化的好处是什么？\n\n组件的分类？\n\n\n九、根组件 App.vue#\n\n\n1.根组件介绍#\n\n整个应用最上层的组件，包裹所有普通小组件\n\n\n\n\n2.组件是由三部分构成#\n\n * 语法高亮插件\n\n\n\n * 三部分构成\n   \n   * template：结构 （有且只能一个根元素）\n   * script：js逻辑\n   * style： 样式 (可支持less，需要装包)\n\n * 让组件支持less\n   \n   （1） style标签，lang=\"less\" 开启less功能\n   \n   （2） 装包: yarn add less less-loader -D 或者npm i less less-loader -D\n\n\n3.总结#\n\nApp组件包含哪三部分？\n\n\n十、普通组件的注册使用-局部注册#\n\n\n1.特点#\n\n只能在注册的组件内使用\n\n\n2.步骤#\n\n 1. 创建.vue文件（三个组成部分）\n 2. 在使用的组件内先导入再注册，最后使用\n\n\n3.使用方式#\n\n当成html标签使用即可 <组件名>\n\n\n4.注意#\n\n组件名规范 —> 大驼峰命名法， 如 HmHeader\n\n\n5.语法#\n\n\n\n\n\n\n6.练习#\n\n在App组件中，完成以下练习。在App.vue中使用组件的方式完成下面布局\n\n\n\n\n\n\n\n\n\n\n7.总结#\n\n * A组件内部注册的局部组件能在B组件使用吗\n * 局部注册组件的步骤是什么\n * 使用组件时 应该按照什么命名法\n\n\n十一、普通组件的注册使用-全局注册#\n\n\n1.特点#\n\n全局注册的组件，在项目的任何组件中都能使用\n\n\n2.步骤#\n\n 1. 创建.vue组件（三个组成部分）\n 2. main.js中进行全局注册\n\n\n3.使用方式#\n\n当成HTML标签直接使用\n\n> <组件名>\n\n\n4.注意#\n\n组件名规范 —> 大驼峰命名法， 如 HmHeader\n\n\n5.语法#\n\nVue.component('组件名', 组件对象)\n\n例：\n\n\n\n\n6.练习#\n\n在以下3个局部组件中是展示一个通用按钮\n\n\n\n\n\n\n7.总结#\n\n1.全局注册组件应该在哪个文件中注册以及语法是什么？\n\n2.全局组件在项目中的任何一个组件中可不可以使用？\n\n\n十二、综合案例#\n\n\n1.小兔仙首页启动项目演示#\n\n\n2.小兔仙组件拆分示意图#\n\n\n\n\n3.开发思路#\n\n 1. 分析页面，按模块拆分组件，搭架子 (局部或全局注册)\n\n 2. 根据设计图，编写组件 html 结构 css 样式 (已准备好)\n\n 3. 拆分封装通用小组件 (局部或全局注册)\n    \n    将来 → 通过 js 动态渲染，实现功能","routePath":"/vue/day03/day03","lang":"","toc":[{"text":"一、今日目标","id":"一今日目标","depth":2,"charIndex":3},{"text":"1.生命周期","id":"1生命周期","depth":3,"charIndex":13},{"text":"2.综合案例-小黑记账清单","id":"2综合案例-小黑记账清单","depth":3,"charIndex":71},{"text":"3.工程化开发入门","id":"3工程化开发入门","depth":3,"charIndex":117},{"text":"4.综合案例-小兔仙首页","id":"4综合案例-小兔仙首页","depth":3,"charIndex":173},{"text":"二、Vue生命周期","id":"二vue生命周期","depth":2,"charIndex":231},{"text":"三、Vue生命周期钩子","id":"三vue生命周期钩子","depth":2,"charIndex":426},{"text":"四、生命周期钩子小案例","id":"四生命周期钩子小案例","depth":2,"charIndex":501},{"text":"1.在created中发送数据","id":"1在created中发送数据","depth":3,"charIndex":516},{"text":"2.在mounted中获取焦点","id":"2在mounted中获取焦点","depth":3,"charIndex":537},{"text":"五、案例-小黑记账清单","id":"五案例-小黑记账清单","depth":2,"charIndex":558},{"text":"1.需求图示","id":"1需求图示","depth":3,"charIndex":573},{"text":"2.需求分析","id":"2需求分析","depth":3,"charIndex":585},{"text":"3.思路分析","id":"3思路分析","depth":3,"charIndex":627},{"text":"4.代码准备","id":"4代码准备","depth":3,"charIndex":969},{"text":"六、工程化开发和脚手架","id":"六工程化开发和脚手架","depth":2,"charIndex":981},{"text":"1.开发Vue的两种方式","id":"1开发vue的两种方式","depth":3,"charIndex":996},{"text":"2.脚手架Vue CLI","id":"2脚手架vue-cli","depth":3,"charIndex":1271},{"text":"基本介绍","id":"基本介绍","depth":4,"charIndex":1286},{"text":"好处","id":"好处","depth":4,"charIndex":1364},{"text":"使用步骤","id":"使用步骤","depth":4,"charIndex":1416},{"text":"七、项目目录介绍和运行流程","id":"七项目目录介绍和运行流程","depth":2,"charIndex":1625},{"text":"1.项目目录介绍","id":"1项目目录介绍","depth":3,"charIndex":1642},{"text":"2.运行流程","id":"2运行流程","depth":3,"charIndex":1742},{"text":"八、组件化开发","id":"八组件化开发","depth":2,"charIndex":1754},{"text":"九、根组件 App.vue","id":"九根组件-appvue","depth":2,"charIndex":1933},{"text":"1.根组件介绍","id":"1根组件介绍","depth":3,"charIndex":1950},{"text":"2.组件是由三部分构成","id":"2组件是由三部分构成","depth":3,"charIndex":1985},{"text":"3.总结","id":"3总结","depth":3,"charIndex":2229},{"text":"十、普通组件的注册使用-局部注册","id":"十普通组件的注册使用-局部注册","depth":2,"charIndex":2251},{"text":"1.特点","id":"1特点","depth":3,"charIndex":2271},{"text":"2.步骤","id":"2步骤","depth":3,"charIndex":2292},{"text":"3.使用方式","id":"3使用方式","depth":3,"charIndex":2345},{"text":"4.注意","id":"4注意","depth":3,"charIndex":2375},{"text":"5.语法","id":"5语法","depth":3,"charIndex":2412},{"text":"6.练习","id":"6练习","depth":3,"charIndex":2424},{"text":"7.总结","id":"7总结","depth":3,"charIndex":2479},{"text":"十一、普通组件的注册使用-全局注册","id":"十一普通组件的注册使用-全局注册","depth":2,"charIndex":2547},{"text":"1.特点","id":"1特点-1","depth":3,"charIndex":2568},{"text":"2.步骤","id":"2步骤-1","depth":3,"charIndex":2599},{"text":"3.使用方式","id":"3使用方式-1","depth":3,"charIndex":2648},{"text":"4.注意","id":"4注意-1","depth":3,"charIndex":2681},{"text":"5.语法","id":"5语法-1","depth":3,"charIndex":2718},{"text":"6.练习","id":"6练习-1","depth":3,"charIndex":2760},{"text":"7.总结","id":"7总结-1","depth":3,"charIndex":2793},{"text":"十二、综合案例","id":"十二综合案例","depth":2,"charIndex":2856},{"text":"1.小兔仙首页启动项目演示","id":"1小兔仙首页启动项目演示","depth":3,"charIndex":2867},{"text":"2.小兔仙组件拆分示意图","id":"2小兔仙组件拆分示意图","depth":3,"charIndex":2884},{"text":"3.开发思路","id":"3开发思路","depth":3,"charIndex":2902}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"day04","content":"#\n\n\n一、学习目标#\n\n\n1.组件的三大组成部分（结构/样式/逻辑）#\n\nscoped解决样式冲突/data是一个函数\n\n\n2.组件通信#\n\n 1. 组件通信语法\n 2. 父传子\n 3. 子传父\n 4. 非父子通信（扩展）\n\n\n3.综合案例：小黑记事本（组件版）#\n\n 1. 拆分组件\n 2. 列表渲染\n 3. 数据添加\n 4. 数据删除\n 5. 列表统计\n 6. 清空\n 7. 持久化\n\n\n4.进阶语法#\n\n 1. v-model原理\n 2. v-model应用于组件\n 3. sync修饰符\n 4. ref和$refs\n 5. $nextTick\n\n\n二、scoped解决样式冲突#\n\n\n1.默认情况#\n\n写在组件中的样式会 全局生效 → 因此很容易造成多个组件之间的样式冲突问题。\n\n 1. 全局样式: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响\n\n 2. 局部样式: 可以给组件加上scoped 属性,可以让样式只作用于当前组件\n\n\n2.代码演示#\n\nBaseOne.vue\n\n\n\nBaseTwo.vue\n\n\n\nApp.vue\n\n\n\n\n3.scoped原理#\n\n 1. 当前组件内标签都被添加data-v-hash值 的属性\n 2. css选择器都被添加 [data-v-hash值] 的属性选择器\n\n最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到\n\n\n\n\n4.总结#\n\n 1. style的默认样式是作用到哪里的？\n 2. scoped的作用是什么？\n 3. style中推不推荐加scoped？\n\n\n三、data必须是一个函数#\n\n\n1、data为什么要写成函数#\n\n一个组件的 data 选项必须是一个函数。目的是为了：保证每个组件实例，维护独立的一份数据对象。\n\n每次创建新的组件实例，都会新执行一次data 函数，得到一个新对象。\n\n\n\n\n2.代码演示#\n\nBaseCount.vue\n\n\n\nApp.vue\n\n\n\n\n3.总结#\n\ndata写成函数的目的是什么？\n\n\n四、组件通信#\n\n\n1.什么是组件通信？#\n\n组件通信，就是指组件与组件之间的数据传递\n\n * 组件的数据是独立的，无法直接访问其他组件的数据。\n * 想使用其他组件的数据，就需要组件通信\n\n\n2.组件之间如何通信#\n\n\n\n思考：\n\n 1. 组件之间有哪些关系？\n 2. 对应的组件通信方案有哪几类？\n\n\n3.组件关系分类#\n\n 1. 父子关系\n 2. 非父子关系\n\n\n\n\n4.通信解决方案#\n\n\n\n\n5.父子通信流程#\n\n 1. 父组件通过 props 将数据传递给子组件\n 2. 子组件利用 $emit 通知父组件修改更新\n\n\n\n\n6.父向子通信代码示例#\n\n父组件通过props将数据传递给子组件\n\n父组件App.vue\n\n\n\n子组件Son.vue\n\n\n\n\n\n父向子传值步骤\n\n 1. 给子组件以添加属性的方式传值\n 2. 子组件内部通过props接收\n 3. 模板中直接使用 props接收的值\n\n\n7.子向父通信代码示例#\n\n子组件利用 $emit 通知父组件，进行修改更新\n\n\n\n子向父传值步骤\n\n 1. $emit触发事件，给父组件发送消息通知\n 2. 父组件监听$emit触发的事件\n 3. 提供处理函数，在函数的性参中获取传过来的参数\n\n\n8.总结#\n\n 1. 组件关系分类有哪两种\n 2. 父子组件通信的流程是什么？\n    1. 父向子\n    2. 子向父\n\n\n五、什么是props#\n\n\n1.Props 定义#\n\n组件上 注册的一些 自定义属性\n\n\n2.Props 作用#\n\n向子组件传递数据\n\n\n3.特点#\n\n 1. 可以 传递 任意数量 的prop\n 2. 可以 传递 任意类型 的prop\n\n\n\n\n4.代码演示#\n\n父组件App.vue\n\n\n\n子组件UserInfo.vue\n\n\n\n\n六、props校验#\n\n\n1.思考#\n\n组件的props可以乱传吗\n\n\n2.作用#\n\n为组件的 prop 指定验证要求，不符合要求，控制台就会有错误提示 → 帮助开发者，快速发现错误\n\n\n3.语法#\n\n * 类型校验\n * 非空校验\n * 默认值\n * 自定义校验\n\n\n\n\n4.代码演示#\n\nApp.vue\n\n\n\nBaseProgress.vue\n\n\n\n\n七、props校验完整写法#\n\n\n1.语法#\n\n\n\n\n2.代码实例#\n\n\n\n\n3.注意#\n\n1.default和required一般不同时写（因为当时必填项时，肯定是有值的）\n\n2.default后面如果是简单类型的值，可以直接写默认。如果是复杂类型的值，则需要以函数的形式return一个默认值\n\n\n八、props&data、单向数据流#\n\n\n1.共同点#\n\n都可以给组件提供数据\n\n\n2.区别#\n\n * data 的数据是自己的 → 随便改\n * prop 的数据是外部的 → 不能直接改，要遵循 单向数据流\n\n\n3.单向数据流#\n\n父级props 的数据更新，会向下流动，影响子组件。这个数据流动是单向的\n\n\n4.代码演示#\n\nApp.vue\n\n\n\nBaseCount.vue\n\n\n\n\n\n\n5.口诀#\n\n谁的数据谁负责#\n\n\n九、综合案例-组件拆分#\n\n\n1.需求说明#\n\n * 拆分基础组件\n * 渲染待办任务\n * 添加任务\n * 删除任务\n * 底部合计 和 清空功能\n * 持久化存储\n\n\n2.拆分基础组件#\n\n咱们可以把小黑记事本原有的结构拆成三部分内容：头部（TodoHeader）、列表(TodoMain)、底部(TodoFooter)\n\n\n\n\n十、综合案例-列表渲染#\n\n思路分析：\n\n 1. 提供数据：提供在公共的父组件 App.vue\n 2. 通过父传子，将数据传递给TodoMain\n 3. 利用v-for进行渲染\n\n\n十一、综合案例-添加功能#\n\n思路分析：\n\n 1. 收集表单数据 v-model\n 2. 监听时间 （回车-点击 都要进行添加）\n 3. 子传父，将任务名称传递给父组件App.vue\n 4. 父组件接受到数据后 进行添加 unshift(自己的数据自己负责)\n\n\n十二、综合案例-删除功能#\n\n思路分析：\n\n 1. 监听时间（监听删除的点击）携带id\n 2. 子传父，将删除的id传递给父组件App.vue\n 3. 进行删除 filter (自己的数据自己负责)\n\n\n十三、综合案例-底部功能及持久化存储#\n\n思路分析：\n\n 1. 底部合计：父组件传递list到底部组件 —>展示合计\n 2. 清空功能：监听事件 —> 子组件通知父组件 —>父组件清空\n 3. 持久化存储：watch监听数据变化，持久化到本地\n\n\n十四、非父子通信-event bus 事件总线#\n\n\n1.作用#\n\n非父子组件之间，进行简易消息传递。(复杂场景→ Vuex)\n\n\n2.步骤#\n\n 1. 创建一个都能访问的事件总线 （空Vue实例）\n    \n    \n\n 2. A组件（接受方），监听Bus的 $on事件\n    \n    \n\n 3. B组件（发送方），触发Bus的$emit事件\n    \n    \n    \n    \n\n\n3.代码示例#\n\nEventBus.js\n\n\n\nBaseA.vue(接受方)\n\n\n\nBaseB.vue(发送方)\n\n\n\nApp.vue\n\n\n\n\n4.总结#\n\n1.非父子组件传值借助什么？\n\n2.什么是事件总线\n\n3.发送方应该调用事件总线的哪个方法\n\n4.接收方应该调用事件总线的哪个方法\n\n5.一个组件发送数据，可不可以被多个组件接收\n\n\n十五、非父子通信-provide&inject#\n\n\n1.作用#\n\n跨层级共享数据\n\n\n2.场景#\n\n\n\n\n3.语法#\n\n 1. 父组件 provide提供数据\n\n\n\n2.子/孙组件 inject获取数据\n\n\n\n\n4.注意#\n\n * provide提供的简单类型的数据不是响应式的，复杂类型数据是响应式。（推荐提供复杂类型数据）\n * 子/孙组件通过inject获取的数据，不能在自身组件内修改\n\n\n十六、v-model原理#\n\n\n1.原理#\n\nv-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写\n\n\n\n\n2.作用#\n\n提供数据的双向绑定\n\n * 数据变，视图跟着变 :value\n * 视图变，数据跟着变 @input\n\n\n3.注意#\n\n$event 用于在模板中，获取事件的形参\n\n\n4.代码示例#\n\n\n\n\n5.v-model使用在其他表单元素上的原理#\n\n不同的表单元素， v-model在底层的处理机制是不一样的。比如给checkbox使用v-model\n\n底层处理的是 checked属性和change事件。\n\n不过咱们只需要掌握应用在文本框上的原理即可#\n\n\n十七、表单类组件封装#\n\n\n1.需求目标#\n\n实现子组件和父组件数据的双向绑定 （实现App.vue中的selectId和子组件选中的数据进行双向绑定）\n\n\n2.代码演示#\n\nApp.vue\n\n\n\nBaseSelect.vue\n\n\n\n\n十八、v-model简化代码#\n\n\n1.目标#\n\n父组件通过v-model 简化代码，实现子组件和父组件数据 双向绑定\n\n\n2.如何简化#\n\nv-model其实就是 :value和@input事件的简写\n\n * 子组件：props通过value接收数据，事件触发 input\n * 父组件：v-model直接绑定数据\n\n\n3.代码示例#\n\n子组件\n\n\n\n父组件\n\n\n\n\n十九、.sync修饰符#\n\n\n1.作用#\n\n可以实现 子组件 与 父组件数据 的 双向绑定，简化代码\n\n简单理解：子组件可以修改父组件传过来的props值\n\n\n2.场景#\n\n封装弹框类的基础组件， visible属性 true显示 false隐藏\n\n\n3.本质#\n\n.sync修饰符 就是 :属性名 和 @update:属性名 合写\n\n\n4.语法#\n\n父组件\n\n\n\n子组件\n\n\n\n\n5.代码示例#\n\nApp.vue\n\n\n\nBaseDialog.vue\n\n\n\n\n6.总结#\n\n1.父组件如果想让子组件修改传过去的值 必须加什么修饰符？\n\n2.子组件要修改父组件的props值 必须使用什么语法？\n\n\n二十、ref和$refs#\n\n\n1.作用#\n\n利用ref 和 $refs 可以用于 获取 dom 元素 或 组件实例\n\n\n2.特点#\n\n查找范围 → 当前组件内(更精确稳定)\n\n\n3.语法#\n\n1.给要获取的盒子添加ref属性\n\n\n\n2.获取时通过 $refs获取 this.$refs.chartRef 获取\n\n\n\n\n4.注意#\n\n之前只用document.querySelect('.box') 获取的是整个页面中的盒子\n\n\n5.代码示例#\n\nApp.vue\n\n\n\nBaseChart.vue\n\n\n\n\n二十一、异步更新 & $nextTick#\n\n\n1.需求#\n\n编辑标题, 编辑框自动聚焦\n\n 1. 点击编辑，显示编辑框\n 2. 让编辑框，立刻获取焦点\n\n\n\n\n2.代码实现#\n\n\n\n\n3.问题#\n\n\"显示之后\"，立刻获取焦点是不能成功的！\n\n原因：Vue 是异步更新DOM (提升性能)\n\n\n4.解决方案#\n\n$nextTick：等 DOM更新后,才会触发执行此方法里的函数体\n\n语法: this.$nextTick(函数体)\n\n\n\n注意：$nextTick 内的函数体 一定是箭头函数，这样才能让函数内部的this指向Vue实例","routePath":"/vue/day04/day04","lang":"","toc":[{"text":"一、学习目标","id":"一学习目标","depth":2,"charIndex":3},{"text":"1.组件的三大组成部分（结构/样式/逻辑）","id":"1组件的三大组成部分结构样式逻辑","depth":3,"charIndex":13},{"text":"2.组件通信","id":"2组件通信","depth":3,"charIndex":62},{"text":"3.综合案例：小黑记事本（组件版）","id":"3综合案例小黑记事本组件版","depth":3,"charIndex":114},{"text":"4.进阶语法","id":"4进阶语法","depth":3,"charIndex":196},{"text":"二、scoped解决样式冲突","id":"二scoped解决样式冲突","depth":2,"charIndex":278},{"text":"**1.默认情况**","id":"1默认情况","depth":3,"charIndex":-1},{"text":"2.代码演示","id":"2代码演示","depth":3,"charIndex":432},{"text":"3.scoped原理","id":"3scoped原理","depth":3,"charIndex":483},{"text":"4.总结","id":"4总结","depth":3,"charIndex":611},{"text":"三、data必须是一个函数","id":"三data必须是一个函数","depth":2,"charIndex":684},{"text":"1、data为什么要写成函数","id":"1data为什么要写成函数","depth":3,"charIndex":701},{"text":"2.代码演示","id":"2代码演示-1","depth":3,"charIndex":807},{"text":"3.总结","id":"3总结","depth":3,"charIndex":845},{"text":"四、组件通信","id":"四组件通信","depth":2,"charIndex":870},{"text":"1.什么是组件通信？","id":"1什么是组件通信","depth":3,"charIndex":880},{"text":"2.组件之间如何通信","id":"2组件之间如何通信","depth":3,"charIndex":967},{"text":"3.组件关系分类","id":"3组件关系分类","depth":3,"charIndex":1023},{"text":"4.通信解决方案","id":"4通信解决方案","depth":3,"charIndex":1057},{"text":"5.父子通信流程","id":"5父子通信流程","depth":3,"charIndex":1071},{"text":"6.父向子通信代码示例","id":"6父向子通信代码示例","depth":3,"charIndex":1138},{"text":"7.子向父通信代码示例","id":"7子向父通信代码示例","depth":3,"charIndex":1274},{"text":"8.总结","id":"8总结","depth":3,"charIndex":1399},{"text":"五、什么是props","id":"五什么是props","depth":2,"charIndex":1463},{"text":"1.Props 定义","id":"1props-定义","depth":3,"charIndex":1477},{"text":"2.Props 作用","id":"2props-作用","depth":3,"charIndex":1508},{"text":"3.特点","id":"3特点","depth":3,"charIndex":1532},{"text":"4.代码演示","id":"4代码演示","depth":3,"charIndex":1585},{"text":"六、props校验","id":"六props校验","depth":2,"charIndex":1628},{"text":"1.思考","id":"1思考","depth":3,"charIndex":1641},{"text":"2.作用","id":"2作用","depth":3,"charIndex":1664},{"text":"3.语法","id":"3语法","depth":3,"charIndex":1722},{"text":"4.代码演示","id":"4代码演示-1","depth":3,"charIndex":1765},{"text":"七、props校验完整写法","id":"七props校验完整写法","depth":2,"charIndex":1806},{"text":"1.语法","id":"1语法","depth":3,"charIndex":1823},{"text":"2.代码实例","id":"2代码实例","depth":3,"charIndex":1833},{"text":"3.注意","id":"3注意","depth":3,"charIndex":1845},{"text":"八、props&data、单向数据流","id":"八propsdata单向数据流","depth":2,"charIndex":1957},{"text":"1.共同点","id":"1共同点","depth":3,"charIndex":1979},{"text":"2.区别","id":"2区别","depth":3,"charIndex":2000},{"text":"3.单向数据流","id":"3单向数据流","depth":3,"charIndex":2065},{"text":"4.代码演示","id":"4代码演示-2","depth":3,"charIndex":2114},{"text":"5.口诀","id":"5口诀","depth":3,"charIndex":2154},{"text":"谁的数据谁负责","id":"谁的数据谁负责","depth":4,"charIndex":2161},{"text":"九、综合案例-组件拆分","id":"九综合案例-组件拆分","depth":2,"charIndex":2172},{"text":"1.需求说明","id":"1需求说明","depth":3,"charIndex":2187},{"text":"2.拆分基础组件","id":"2拆分基础组件","depth":3,"charIndex":2258},{"text":"十、综合案例-列表渲染","id":"十综合案例-列表渲染","depth":2,"charIndex":2339},{"text":"十一、综合案例-添加功能","id":"十一综合案例-添加功能","depth":2,"charIndex":2430},{"text":"十二、综合案例-删除功能","id":"十二综合案例-删除功能","depth":2,"charIndex":2562},{"text":"十三、综合案例-底部功能及持久化存储","id":"十三综合案例-底部功能及持久化存储","depth":2,"charIndex":2664},{"text":"十四、非父子通信-event bus 事件总线","id":"十四非父子通信-event-bus-事件总线","depth":2,"charIndex":2788},{"text":"1.作用","id":"1作用","depth":3,"charIndex":2815},{"text":"2.步骤","id":"2步骤","depth":3,"charIndex":2854},{"text":"3.代码示例","id":"3代码示例","depth":3,"charIndex":2985},{"text":"4.总结","id":"4总结-1","depth":3,"charIndex":3057},{"text":"十五、非父子通信-provide&inject","id":"十五非父子通信-provideinject","depth":2,"charIndex":3156},{"text":"1.作用","id":"1作用-1","depth":3,"charIndex":3183},{"text":"2.场景","id":"2场景","depth":3,"charIndex":3200},{"text":"3.语法","id":"3语法-1","depth":3,"charIndex":3210},{"text":"4.注意","id":"4注意","depth":3,"charIndex":3263},{"text":"十六、v-model原理","id":"十六v-model原理","depth":2,"charIndex":3356},{"text":"1.原理","id":"1原理","depth":3,"charIndex":3372},{"text":"2.作用","id":"2作用-1","depth":3,"charIndex":3434},{"text":"3.注意","id":"3注意-1","depth":3,"charIndex":3494},{"text":"4.代码示例","id":"4代码示例","depth":3,"charIndex":3525},{"text":"5.v-model使用在其他表单元素上的原理","id":"5v-model使用在其他表单元素上的原理","depth":3,"charIndex":3537},{"text":"不过咱们只需要掌握应用在文本框上的原理即可","id":"不过咱们只需要掌握应用在文本框上的原理即可","depth":4,"charIndex":3642},{"text":"十七、表单类组件封装","id":"十七表单类组件封装","depth":2,"charIndex":3667},{"text":"1.需求目标","id":"1需求目标","depth":3,"charIndex":3681},{"text":"2.代码演示","id":"2代码演示-2","depth":3,"charIndex":3746},{"text":"十八、v-model简化代码","id":"十八v-model简化代码","depth":2,"charIndex":3785},{"text":"1.目标","id":"1目标","depth":3,"charIndex":3803},{"text":"2.如何简化","id":"2如何简化","depth":3,"charIndex":3847},{"text":"3.代码示例","id":"3代码示例-1","depth":3,"charIndex":3946},{"text":"十九、.sync修饰符","id":"十九sync修饰符","depth":2,"charIndex":3970},{"text":"1.作用","id":"1作用-2","depth":3,"charIndex":3985},{"text":"2.场景","id":"2场景-1","depth":3,"charIndex":4050},{"text":"3.本质","id":"3本质","depth":3,"charIndex":4096},{"text":"4.语法","id":"4语法","depth":3,"charIndex":4139},{"text":"5.代码示例","id":"5代码示例","depth":3,"charIndex":4161},{"text":"6.总结","id":"6总结","depth":3,"charIndex":4200},{"text":"二十、ref和$refs","id":"二十ref和refs","depth":2,"charIndex":4269},{"text":"1.作用","id":"1作用-3","depth":3,"charIndex":4285},{"text":"2.特点","id":"2特点","depth":3,"charIndex":4330},{"text":"3.语法","id":"3语法-2","depth":3,"charIndex":4359},{"text":"4.注意","id":"4注意-1","depth":3,"charIndex":4429},{"text":"5.代码示例","id":"5代码示例-1","depth":3,"charIndex":4484},{"text":"二十一、异步更新 & $nextTick","id":"二十一异步更新--nexttick","depth":2,"charIndex":4522},{"text":"1.需求","id":"1需求","depth":3,"charIndex":4546},{"text":"2.代码实现","id":"2代码实现","depth":3,"charIndex":4603},{"text":"3.问题","id":"3问题","depth":3,"charIndex":4615},{"text":"4.解决方案","id":"4解决方案","depth":3,"charIndex":4669}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"day05","content":"#\n\n\n一、学习目标#\n\n\n1.自定义指令#\n\n * 基本语法（全局、局部注册）\n * 指令的值\n * v-loading的指令封装\n\n\n2.插槽#\n\n * 默认插槽\n * 具名插槽\n * 作用域插槽\n\n\n3.综合案例：商品列表#\n\n * MyTag组件封装\n * MyTable组件封装\n\n\n4.路由入门#\n\n * 单页应用程序\n * 路由\n * VueRouter的基本使用\n\n\n二、自定义指令#\n\n\n1.指令介绍#\n\n * 内置指令：v-html、v-if、v-bind、v-on... 这都是Vue给咱们内置的一些指令，可以直接使用\n\n * 自定义指令：同时Vue也支持让开发者，自己注册一些指令。这些指令被称为自定义指令\n   \n   每个指令都有自己各自独立的功能\n\n\n2.自定义指令#\n\n概念：自己定义的指令，可以封装一些DOM操作，扩展额外的功能\n\n\n3.自定义指令语法#\n\n * 全局注册\n   \n   \n\n * 局部注册\n   \n   \n\n * 使用指令\n   \n   注意：在使用指令的时候，一定要先注册，再使用，否则会报错 使用指令语法： v-指令名。如：\n   \n   注册指令时不用加v-前缀，但使用时一定要加v-前缀\n\n\n4.指令中的配置项介绍#\n\ninserted:被绑定元素插入父节点时调用的钩子函数\n\nel：使用指令的那个DOM元素\n\n\n5.代码示例#\n\n需求：当页面加载时，让元素获取焦点（autofocus在safari浏览器有兼容性）\n\nApp.vue\n\n\n\n\n6.总结#\n\n1.自定义指令的作用是什么？\n\n2.使用自定义指令的步骤是哪两步？\n\n\n三、自定义指令-指令的值#\n\n\n1.需求#\n\n实现一个 color 指令 - 传入不同的颜色, 给标签设置文字颜色\n\n\n2.语法#\n\n1.在绑定指令时，可以通过“等号”的形式为指令 绑定 具体的参数值\n\n\n\n2.通过 binding.value 可以拿到指令值，指令值修改会 触发 update 函数\n\n\n\n\n3.代码示例#\n\nApp.vue\n\n\n\n\n四、自定义指令-v-loading指令的封装#\n\n\n1.场景#\n\n实际开发过程中，发送请求需要时间，在请求的数据未回来时，页面会处于空白状态 => 用户体验不好\n\n\n2.需求#\n\n封装一个 v-loading 指令，实现加载中的效果\n\n\n3.分析#\n\n1.本质 loading效果就是一个蒙层，盖在了盒子上\n\n2.数据请求中，开启loading状态，添加蒙层\n\n3.数据请求完毕，关闭loading状态，移除蒙层\n\n\n4.实现#\n\n1.准备一个 loading类，通过伪元素定位，设置宽高，实现蒙层\n\n2.开启关闭 loading状态（添加移除蒙层），本质只需要添加移除类即可\n\n3.结合自定义指令的语法进行封装复用\n\n\n\n\n5.准备代码#\n\n\n\n\n五、插槽-默认插槽#\n\n\n1.作用#\n\n让组件内部的一些 结构 支持 自定义\n\n\n\n\n2.需求#\n\n将需要多次显示的对话框,封装成一个组件\n\n\n3.问题#\n\n组件的内容部分，不希望写死，希望能使用的时候自定义。怎么办\n\n\n4.插槽的基本语法#\n\n 1. 组件内需要定制的结构部分，改用占位\n 2. 使用组件时, 标签内部, 传入结构替换slot\n 3. 给插槽传入内容时，可以传入纯文本、html标签、组件\n\n\n\n\n5.代码示例#\n\nMyDialog.vue\n\n\n\nApp.vue\n\n\n\n\n6.总结#\n\n场景：组件内某一部分结构不确定，想要自定义怎么办\n\n使用：插槽的步骤分为哪几步？\n\n\n六、插槽-后备内容（默认值）#\n\n\n1.问题#\n\n通过插槽完成了内容的定制，传什么显示什么, 但是如果不传，则是空白\n\n\n\n能否给插槽设置 默认显示内容 呢？\n\n\n2.插槽的后备内容#\n\n封装组件时，可以为预留的 插槽提供后备内容（默认内容）。\n\n\n3.语法#\n\n在标签内，放置内容, 作为默认显示内容\n\n\n\n\n4.效果#\n\n * 外部使用组件时，不传东西，则slot会显示后备内容\n   \n   \n\n * 外部使用组件时，传东西了，则slot整体会被换掉\n   \n   \n\n\n5.代码示例#\n\nApp.vue\n\n\n\n\n七、插槽-具名插槽#\n\n\n1.需求#\n\n一个组件内有多处结构，需要外部传入标签，进行定制\n\n上面的弹框中有三处不同，但是默认插槽只能定制一个位置，这时候怎么办呢?\n\n\n2.具名插槽语法#\n\n * 多个slot使用name属性区分名字\n   \n   \n\n * template配合v-slot:名字来分发对应标签\n   \n   \n\n\n3.v-slot的简写#\n\nv-slot写起来太长，vue给我们提供一个简单写法 v-slot —> #\n\n\n4.总结#\n\n * 组件内 有多处不确定的结构 怎么办?\n * 具名插槽的语法是什么？\n * v-slot:插槽名可以简化成什么?\n\n\n八、作用域插槽#\n\n\n1.插槽分类#\n\n * 默认插槽\n\n * 具名插槽\n   \n   插槽只有两种，作用域插槽不属于插槽的一种分类\n\n\n2.作用#\n\n定义slot 插槽的同时, 是可以传值的。给 插槽 上可以 绑定数据，将来 使用组件时可以用\n\n\n3.场景#\n\n封装表格组件\n\n\n\n\n4.使用步骤#\n\n 1. 给 slot 标签, 以 添加属性的方式传值\n    \n    \n\n 2. 所有添加的属性, 都会被收集到一个对象中\n    \n    \n\n 3. 在template中, 通过 #插槽名= \"obj\" 接收，默认插槽名为 default\n    \n    \n\n\n5.代码示例#\n\nMyTable.vue\n\n\n\nApp.vue\n\n\n\n\n6.总结#\n\n1.作用域插槽的作用是什么？\n\n2.作用域插槽的使用步骤是什么？\n\n\n九、综合案例 - 商品列表-MyTag组件抽离#\n\n\n\n\n1.需求说明#\n\n 1. my-tag 标签组件封装\n    \n    1. 双击显示输入框，输入框获取焦点\n    \n    2. 失去焦点，隐藏输入框\n    \n    3. 回显标签信息\n    \n    4. 内容修改，回车 → 修改标签信息\n\n 2. my-table 表格组件封装\n    \n    1. 动态传递表格数据渲染\n    \n    2. 表头支持用户自定义\n    \n    3. 主体支持用户自定义\n\n\n2.代码准备#\n\n\n\n\n3.my-tag组件封装-创建组件#\n\nMyTag.vue\n\n\n\nApp.vue\n\n\n\n\n十、综合案例-MyTag组件控制显示隐藏#\n\nMyTag.vue\n\n\n\nmain.js\n\n\n\n\n十一、综合案例-MyTag组件进行v-model绑定#\n\nApp.vue\n\n\n\nMyTag.vue\n\n\n\n\n十二、综合案例-封装MyTable组件-动态渲染数据#\n\nApp.vue\n\n\n\nMyTable.vue\n\n\n\n\n十三、综合案例-封装MyTable组件-自定义结构#\n\nApp.vue\n\n\n\nMyTable.vue\n\n\n\n\n十四、单页应用程序介绍#\n\n\n1.概念#\n\n单页应用程序：SPA【Single Page Application】是指所有的功能都在一个html页面上实现\n\n\n2.具体示例#\n\n单页应用网站： 网易云音乐 https://music.163.com/\n\n多页应用网站：京东 https://jd.com/\n\n\n3.单页应用 VS 多页面应用#\n\n\n\n单页应用类网站：系统类网站 / 内部网站 / 文档类网站 / 移动端站点\n\n多页应用类网站：公司官网 / 电商类网站\n\n\n4.总结#\n\n1.什么是单页面应用程序?\n\n2.单页面应用优缺点?\n\n3.单页应用场景？\n\n\n十五、路由介绍#\n\n\n1.思考#\n\n单页面应用程序，之所以开发效率高，性能好，用户体验好\n\n最大的原因就是：页面按需更新\n\n\n\n比如当点击【发现音乐】和【关注】时，只是更新下面部分内容，对于头部是不更新的\n\n要按需更新，首先就需要明确：访问路径和 组件的对应关系！\n\n访问路径 和 组件的对应关系如何确定呢？ 路由\n\n\n2.路由的介绍#\n\n生活中的路由：设备和ip的映射关系\n\n\n\nVue中的路由：路径和组件的映射关系\n\n\n\n\n3.总结#\n\n * 什么是路由\n * Vue中的路由是什么\n\n\n十六、路由的基本使用#\n\n\n1.目标#\n\n认识插件 VueRouter，掌握 VueRouter 的基本使用步骤\n\n\n2.作用#\n\n修改地址栏路径时，切换显示匹配的组件\n\n\n3.说明#\n\nVue 官方的一个路由插件，是一个第三方包\n\n\n4.官网#\n\nhttps://v3.router.vuejs.org/zh/\n\n\n5.VueRouter的使用（5-2）#\n\n固定5个固定的步骤（不用死背，熟能生巧）\n\n 1. 下载 VueRouter 模块到当前工程，版本3.6.5\n    \n    \n\n 2. main.js中引入VueRouter\n    \n    \n\n 3. 安装注册\n    \n    \n\n 4. 创建路由对象\n    \n    \n\n 5. 注入，将路由对象注入到new Vue实例中，建立关联\n    \n    \n\n当我们配置完以上5步之后 就可以看到浏览器地址栏中的路由 变成了 /#/的形式。表示项目的路由已经被Vue-Router管理了\n\n\n\n\n6.代码示例#\n\nmain.js\n\n\n\n\n7.两个核心步骤#\n\n 1. 创建需要的组件 (views目录)，配置路由规则\n    \n    \n\n 2. 配置导航，配置路由出口(路径匹配的组件显示的位置)\n    \n    App.vue\n    \n    \n\n\n8.总结#\n\n 1. 如何实现 路径改变，对应组件 切换,应该使用哪个插件?\n 2. Vue-Router的使用步骤是什么(5-2)?\n\n\n十七、组件的存放目录问题#\n\n注意： .vue文件 本质无区别\n\n\n1.组件分类#\n\n.vue文件分为2类，都是 .vue文件（本质无区别）\n\n * 页面组件 （配置路由规则时使用的组件）\n * 复用组件（多个组件中都使用到的组件）\n\n\n\n\n2.存放目录#\n\n分类开来的目的就是为了 更易维护\n\n 1. src/views文件夹\n    \n    页面组件 - 页面展示 - 配合路由用\n\n 2. src/components文件夹\n    \n    复用组件 - 展示数据 - 常用于复用\n\n\n3.总结#\n\n * 组件分类有哪两类？分类的目的？\n * 不同分类的组件应该放在什么文件夹？作用分别是什么？\n\n\n十八、路由的封装抽离#\n\n问题：所有的路由配置都在main.js中合适吗？\n\n目标：将路由模块抽离出来。 好处：拆分模块，利于维护\n\n\n\n路径简写：\n\n脚手架环境下 @指代src目录，可以用于快速引入组件\n\n总结：\n\n * 路由模块的封装抽离的好处是什么？\n * 以后如何快速引入组件？","routePath":"/vue/day05/day05","lang":"","toc":[{"text":"一、学习目标","id":"一学习目标","depth":2,"charIndex":3},{"text":"1.自定义指令","id":"1自定义指令","depth":3,"charIndex":13},{"text":"2.插槽","id":"2插槽","depth":3,"charIndex":68},{"text":"3.综合案例：商品列表","id":"3综合案例商品列表","depth":3,"charIndex":102},{"text":"4.路由入门","id":"4路由入门","depth":3,"charIndex":146},{"text":"二、自定义指令","id":"二自定义指令","depth":2,"charIndex":191},{"text":"1.指令介绍","id":"1指令介绍","depth":3,"charIndex":202},{"text":"2.自定义指令","id":"2自定义指令","depth":3,"charIndex":340},{"text":"3.自定义指令语法","id":"3自定义指令语法","depth":3,"charIndex":383},{"text":"4.指令中的配置项介绍","id":"4指令中的配置项介绍","depth":3,"charIndex":525},{"text":"5.代码示例","id":"5代码示例","depth":3,"charIndex":586},{"text":"6.总结","id":"6总结","depth":3,"charIndex":651},{"text":"三、自定义指令-指令的值","id":"三自定义指令-指令的值","depth":2,"charIndex":694},{"text":"1.需求","id":"1需求","depth":3,"charIndex":710},{"text":"2.语法","id":"2语法","depth":3,"charIndex":754},{"text":"3.代码示例","id":"3代码示例","depth":3,"charIndex":849},{"text":"四、自定义指令-v-loading指令的封装","id":"四自定义指令-v-loading指令的封装","depth":2,"charIndex":870},{"text":"1.场景","id":"1场景","depth":3,"charIndex":896},{"text":"2.需求","id":"2需求","depth":3,"charIndex":953},{"text":"3.分析","id":"3分析","depth":3,"charIndex":989},{"text":"4.实现","id":"4实现","depth":3,"charIndex":1079},{"text":"5.准备代码","id":"5准备代码","depth":3,"charIndex":1183},{"text":"五、插槽-默认插槽","id":"五插槽-默认插槽","depth":2,"charIndex":1195},{"text":"1.作用","id":"1作用","depth":3,"charIndex":1208},{"text":"2.需求","id":"2需求-1","depth":3,"charIndex":1238},{"text":"3.问题","id":"3问题","depth":3,"charIndex":1267},{"text":"4.插槽的基本语法","id":"4插槽的基本语法","depth":3,"charIndex":1306},{"text":"5.代码示例","id":"5代码示例-1","depth":3,"charIndex":1403},{"text":"6.总结","id":"6总结-1","depth":3,"charIndex":1440},{"text":"六、插槽-后备内容（默认值）","id":"六插槽-后备内容默认值","depth":2,"charIndex":1490},{"text":"1.问题","id":"1问题","depth":3,"charIndex":1508},{"text":"2.插槽的后备内容","id":"2插槽的后备内容","depth":3,"charIndex":1572},{"text":"3.语法","id":"3语法","depth":3,"charIndex":1615},{"text":"4.效果","id":"4效果","depth":3,"charIndex":1646},{"text":"5.代码示例","id":"5代码示例-2","depth":3,"charIndex":1729},{"text":"七、插槽-具名插槽","id":"七插槽-具名插槽","depth":2,"charIndex":1750},{"text":"1.需求","id":"1需求-1","depth":3,"charIndex":1763},{"text":"2.具名插槽语法","id":"2具名插槽语法","depth":3,"charIndex":1834},{"text":"3.v-slot的简写","id":"3v-slot的简写","depth":3,"charIndex":1916},{"text":"4.总结","id":"4总结","depth":3,"charIndex":1971},{"text":"八、作用域插槽","id":"八作用域插槽","depth":2,"charIndex":2039},{"text":"1.插槽分类","id":"1插槽分类","depth":3,"charIndex":2050},{"text":"2.作用","id":"2作用","depth":3,"charIndex":2108},{"text":"3.场景","id":"3场景","depth":3,"charIndex":2164},{"text":"4.使用步骤","id":"4使用步骤","depth":3,"charIndex":2182},{"text":"5.代码示例","id":"5代码示例-3","depth":3,"charIndex":2326},{"text":"6.总结","id":"6总结-2","depth":3,"charIndex":2362},{"text":"九、综合案例 - 商品列表-MyTag组件抽离","id":"九综合案例---商品列表-mytag组件抽离","depth":2,"charIndex":2404},{"text":"1.需求说明","id":"1需求说明","depth":3,"charIndex":2433},{"text":"2.代码准备","id":"2代码准备","depth":3,"charIndex":2649},{"text":"3.my-tag组件封装-创建组件","id":"3my-tag组件封装-创建组件","depth":3,"charIndex":2661},{"text":"十、综合案例-MyTag组件控制显示隐藏","id":"十综合案例-mytag组件控制显示隐藏","depth":2,"charIndex":2706},{"text":"十一、综合案例-MyTag组件进行v-model绑定","id":"十一综合案例-mytag组件进行v-model绑定","depth":2,"charIndex":2754},{"text":"十二、综合案例-封装MyTable组件-动态渲染数据","id":"十二综合案例-封装mytable组件-动态渲染数据","depth":2,"charIndex":2808},{"text":"十三、综合案例-封装MyTable组件-自定义结构","id":"十三综合案例-封装mytable组件-自定义结构","depth":2,"charIndex":2864},{"text":"十四、单页应用程序介绍","id":"十四单页应用程序介绍","depth":2,"charIndex":2919},{"text":"1.概念","id":"1概念","depth":3,"charIndex":2934},{"text":"2.具体示例","id":"2具体示例","depth":3,"charIndex":2999},{"text":"3.单页应用 VS 多页面应用","id":"3单页应用-vs-多页面应用","depth":3,"charIndex":3074},{"text":"4.总结","id":"4总结-1","depth":3,"charIndex":3155},{"text":"十五、路由介绍","id":"十五路由介绍","depth":2,"charIndex":3202},{"text":"1.思考","id":"1思考","depth":3,"charIndex":3213},{"text":"2.路由的介绍","id":"2路由的介绍","depth":3,"charIndex":3362},{"text":"3.总结","id":"3总结","depth":3,"charIndex":3416},{"text":"十六、路由的基本使用","id":"十六路由的基本使用","depth":2,"charIndex":3448},{"text":"1.目标","id":"1目标","depth":3,"charIndex":3462},{"text":"2.作用","id":"2作用-1","depth":3,"charIndex":3507},{"text":"3.说明","id":"3说明","depth":3,"charIndex":3535},{"text":"4.官网","id":"4官网","depth":3,"charIndex":3566},{"text":"5.VueRouter的使用（5-2）","id":"5vuerouter的使用5-2","depth":3,"charIndex":3607},{"text":"6.代码示例","id":"6代码示例","depth":3,"charIndex":3882},{"text":"7.两个核心步骤","id":"7两个核心步骤","depth":3,"charIndex":3903},{"text":"8.总结","id":"8总结","depth":3,"charIndex":4013},{"text":"十七、组件的存放目录问题","id":"十七组件的存放目录问题","depth":2,"charIndex":4083},{"text":"1.组件分类","id":"1组件分类","depth":3,"charIndex":4117},{"text":"2.存放目录","id":"2存放目录","depth":3,"charIndex":4204},{"text":"3.总结","id":"3总结-1","depth":3,"charIndex":4331},{"text":"十八、路由的封装抽离","id":"十八路由的封装抽离","depth":2,"charIndex":4388}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"day06","content":"#\n\n\n一、声明式导航-导航链接#\n\n\n1.需求#\n\n实现导航高亮效果\n\n\n\n如果使用a标签进行跳转的话，需要给当前跳转的导航加样式，同时要移除上一个a标签的样式，太麻烦！！！\n\n\n2.解决方案#\n\nvue-router 提供了一个全局组件 router-link (取代 a 标签)\n\n * 能跳转，配置 to 属性指定路径(必须) 。本质还是 a 标签 ，to 无需 #\n * 能高亮，默认就会提供高亮类名，可以直接设置高亮样式\n\n语法： 发现音乐\n\n\n\n\n3.通过router-link自带的两个样式进行高亮#\n\n使用router-link跳转后，我们发现。当前点击的链接默认加了两个class的值\nrouter-link-exact-active和router-link-active\n\n我们可以给任意一个class属性添加高亮样式即可实现功能\n\n\n4.总结#\n\n * router-link是什么？\n * router-link怎么用？\n * router-link的好处是什么？\n\n\n二、声明式导航-两个类名#\n\n当我们使用跳转时，自动给当前导航加了两个类名\n\n\n\n\n1.router-link-active#\n\n模糊匹配（用的多）\n\nto=\"/my\" 可以匹配 /my /my/a /my/b ....\n\n只要是以/my开头的路径 都可以和 to=\"/my\"匹配到\n\n\n2.router-link-exact-active#\n\n精确匹配\n\nto=\"/my\" 仅可以匹配 /my\n\n\n3.在地址栏中输入二级路由查看类名的添加#\n\n\n4.总结#\n\n * router-link 会自动给当前导航添加两个类名，有什么区别呢？\n\n\n三、声明式导航-自定义类名（了解）#\n\n\n1.问题#\n\nrouter-link的两个高亮类名 太长了，我们希望能定制怎么办\n\n\n\n\n2.解决方案#\n\n我们可以在创建路由对象时，额外配置两个配置项即可。 linkActiveClass和linkExactActiveClass\n\n\n\n\n\n\n3.代码演示#\n\n\n\n\n4.总结#\n\n如何自定义router-link的两个高亮类名\n\n\n四、声明式导航-查询参数传参#\n\n\n1.目标#\n\n在跳转路由时，进行传参\n\n\n\n比如：现在我们在搜索页点击了热门搜索链接，跳转到详情页，需要把点击的内容带到详情页，改怎么办呢？\n\n\n2.跳转传参#\n\n我们可以通过两种方式，在跳转的时候把所需要的参数传到其他页面中\n\n * 查询参数传参\n * 动态路由传参\n\n\n3.查询参数传参#\n\n * 如何传参？\n   \n   \n\n * 如何接受参数\n   \n   固定用法：$router.query.参数名\n\n\n4.代码演示#\n\nApp.vue\n\n\n\nHome.vue\n\n\n\nSearch.vue\n\n\n\nrouter/index.js\n\n\n\nmain.js\n\n\n\n\n五、声明式导航-动态路由传参#\n\n\n1.动态路由传参方式#\n\n * 配置动态路由\n   \n   > 动态路由后面的参数可以随便起名，但要有语义\n   \n   \n\n * 配置导航链接\n   \n   to=\"/path/参数值\"\n\n * 对应页面组件接受参数\n   \n   $route.params.参数名\n   \n   > params后面的参数名要和动态路由配置的参数保持一致\n\n\n2.查询参数传参 VS 动态路由传参#\n\n 1. 查询参数传参 (比较适合传多个参数)\n    \n    1. 跳转：to=\"/path?参数名=值&参数名2=值\"\n    2. 获取：$route.query.参数名\n\n 2. 动态路由传参 (优雅简洁，传单个参数比较方便)\n    \n    1. 配置动态路由：path: \"/path/:参数名\"\n    2. 跳转：to=\"/path/参数值\"\n    3. 获取：$route.params.参数名\n    \n    注意：动态路由也可以传多个参数，但一般只传一个\n\n\n3.总结#\n\n声明式导航跳转时, 有几种方式传值给路由页面？\n\n * 查询参数传参（多个参数）\n * 动态路由传参（一个参数，优雅简洁）\n\n\n六、动态路由参数的可选符(了解)#\n\n\n1.问题#\n\n配了路由 path:\"/search/:words\" 为什么按下面步骤操作，会未匹配到组件，显示空白？\n\n\n\n\n2.原因#\n\n/search/:words 表示，必须要传参数。如果不传参数，也希望匹配，可以加个可选符\"？\"\n\n\n\n\n七、Vue路由-重定向#\n\n\n1.问题#\n\n网页打开时， url 默认是 / 路径，未匹配到组件时，会出现空白\n\n\n\n\n2.解决方案#\n\n重定向 → 匹配 / 后, 强制跳转 /home 路径\n\n\n3.语法#\n\n\n\n\n4.代码演示#\n\n\n\n\n八、Vue路由-404#\n\n\n1.作用#\n\n当路径找不到匹配时，给个提示页面\n\n\n2.位置#\n\n404的路由，虽然配置在任何一个位置都可以，但一般都配置在其他路由规则的最后面\n\n\n3.语法#\n\npath: \"*\" (任意路径) – 前面不匹配就命中最后这个\n\n\n\n\n4.代码示例#\n\nNotFound.vue\n\n\n\nrouter/index.js\n\n\n\n\n九、Vue路由-模式设置#\n\n\n1.问题#\n\n路由的路径看起来不自然, 有#，能否切成真正路径形式?\n\n * hash路由(默认) 例如: http://localhost:8080/#/home\n * history路由(常用) 例如: http://localhost:8080/home\n   (以后上线需要服务器端支持，开发环境webpack给规避掉了history模式的问题)\n\n\n2.语法#\n\n\n\n\n十、编程式导航-两种路由跳转方式#\n\n\n1.问题#\n\n点击按钮跳转如何实现？\n\n\n\n\n2.方案#\n\n编程式导航：用JS代码来进行跳转\n\n\n3.语法#\n\n两种语法：\n\n * path 路径跳转 （简易方便）\n * name 命名路由跳转 (适合 path 路径长的场景)\n\n\n4.path路径跳转语法#\n\n特点：简易方便\n\n\n\n\n5.代码演示 path跳转方式#\n\n\n6.name命名路由跳转#\n\n特点：适合 path 路径长的场景\n\n语法：\n\n * 路由规则，必须配置name配置项\n   \n   \n\n * 通过name来进行跳转\n   \n   \n\n\n7.代码演示通过name命名路由跳转#\n\n\n8.总结#\n\n编程式导航有几种跳转方式？\n\n\n十一、编程式导航-path路径跳转传参#\n\n\n1.问题#\n\n点击搜索按钮，跳转需要把文本框中输入的内容传到下一个页面如何实现？\n\n\n\n\n2.两种传参方式#\n\n1.查询参数\n\n2.动态路由传参\n\n\n3.传参#\n\n两种跳转方式，对于两种传参方式都支持：\n\n① path 路径跳转传参\n\n② name 命名路由跳转传参\n\n\n4.path路径跳转传参（query传参）#\n\n\n\n接受参数的方式依然是：$route.query.参数名\n\n\n5.path路径跳转传参（动态路由传参）#\n\n\n\n接受参数的方式依然是：$route.params.参数值\n\n**注意：**path不能配合params使用\n\n\n十二、编程式导航-name命名路由传参#\n\n\n1.name 命名路由跳转传参 (query传参)#\n\n\n\n\n2.name 命名路由跳转传参 (动态路由传参)#\n\n\n\n\n3.总结#\n\n编程式导航，如何跳转传参？\n\n1.path路径跳转\n\n * query传参\n   \n   \n\n * 动态路由传参\n   \n   \n\n2.name命名路由跳转\n\n * query传参\n   \n   \n\n * 动态路由传参 (需要配动态路由)\n   \n   \n\n\n十三、面经基础版-案例效果分析#\n\n\n1.面经效果演示#\n\n\n2.功能分析#\n\n * 通过演示效果发现，主要的功能页面有两个，一个是列表页，一个是详情页，并且在列表页点击时可以跳转到详情页\n * 底部导航可以来回切换，并且切换时，只有上面的主题内容在动态渲染\n\n\n\n\n3.实现思路分析：配置路由-功能实现#\n\n1.配置路由\n\n * 首页和面经详情页，两个一级路由\n * 首页内嵌套4个可切换的页面（嵌套二级路由）\n\n2.实现功能\n\n * 首页请求渲染\n * 跳转传参 到 详情页，详情页动态渲染\n * 组件缓存，性能优化\n\n\n\n\n十四、面经基础版-一级路由配置#\n\n1.把文档中准备的素材拷贝到项目中\n\n2.针对router/index.js文件 进行一级路由配置\n\n\n\n\n十五、面经基础版-二级路由配置#\n\n二级路由也叫嵌套路由，当然也可以嵌套三级、四级...\n\n\n1.使用场景#\n\n当在页面中点击链接跳转，只是部分内容切换时，我们可以使用嵌套路由\n\n\n2.语法#\n\n * 在一级路由下，配置children属性即可\n * 配置二级路由的出口\n\n1.在一级路由下，配置children属性\n\n注意:一级的路由path 需要加 / 二级路由的path不需要加 /\n\n\n\n技巧：二级路由应该配置到哪个一级路由下呢？\n\n\n这些二级路由对应的组件渲染到哪个一级路由下，children就配置到哪个路由下边#\n\n2.配置二级路由的出口\n\n注意： 配置了嵌套路由，一定配置对应的路由出口，否则不会渲染出对应的组件\n\nLayout.vue\n\n\n\n\n3.代码实现#\n\nrouter/index.js\n\n\n\nLayout.vue\n\n\n\n\n十六、面经基础版-二级导航高亮#\n\n\n1.实现思路#\n\n * 将a标签替换成组件，配置to属性，不用加 #\n * 结合高亮类名实现高亮效果 (推荐模糊匹配：router-link-active)\n\n\n2.代码实现#\n\nLayout.vue\n\n\n\n\n十七、面经基础版-首页请求渲染#\n\n\n1.步骤分析#\n\n1.安装axios\n\n2.看接口文档，确认请求方式，请求地址，请求参数\n\n3.created中发送请求，获取数据，存储到data中\n\n4.页面动态渲染\n\n\n2.代码实现#\n\n1.安装axios\n\nyarn add axios\n\nnpm i axios\n\n2.接口文档\n\n\n\n3.created中发送请求，获取数据，存储到data中\n\n\n\n4.页面动态渲染\n\n\n\n\n十八、面经基础版-查询参数传参#\n\n\n1.说明#\n\n跳转详情页需要把当前点击的文章id传给详情页，获取数据\n\n * 查询参数传参 this.$router.push('/detail?参数1=参数值&参数2=参数值')\n * 动态路由传参 先改造路由 在传参 this.$router.push('/detail/参数值')\n\n\n2.查询参数传参实现#\n\nArticle.vue\n\n\n\nArticleDetail.vue\n\n\n\n\n十九、面经基础版-动态路由传参#\n\n\n1.实现步骤#\n\n * 改造路由\n * 动态传参\n * 在详情页获取参数\n\n\n2.代码实现#\n\n改造路由\n\nrouter/index.js\n\n\n\nArticle.vue\n\n\n\nArticleDetail.vue\n\n\n\n\n3.额外优化功能点-点击回退跳转到上一页#\n\nArticleDetail.vue\n\n\n\n\n二十、面经基础版-详情页渲染#\n\n\n1.实现步骤分析#\n\n * 导入axios\n * 查看接口文档\n * 在created中发送请求\n * 页面动态渲染\n\n\n2.代码实现#\n\n接口文档\n\n\n\n在created中发送请求\n\n\n\n页面动态渲染\n\n\n\n\n二十一、面经基础版-缓存组件#\n\n\n1.问题#\n\n从面经列表 点到 详情页，又点返回，数据重新加载了 → 希望回到原来的位置\n\n\n\n\n2.原因#\n\n当路由被跳转后，原来所看到的组件就被销毁了（会执行组件内的beforeDestroy和destroyed生命周期钩子），重新返回后组件又被重新创建了（会执行组件\n内的beforeCreate,created,beforeMount,Mounted生命周期钩子），所以数据被加载了\n\n\n3.解决方案#\n\n利用keep-alive把原来的组件给缓存下来\n\n\n4.什么是keep-alive#\n\nkeep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\n\nkeep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。\n\n优点：\n\n在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，\n\n减少加载时间及性能消耗，提高用户体验性。\n\nApp.vue\n\n\n\n问题：\n\n缓存了所有被切换的组件\n\n\n5.keep-alive的三个属性#\n\n① include ： 组件名数组，只有匹配的组件会被缓存\n\n② exclude ： 组件名数组，任何匹配的组件都不会被缓存\n\n③ max ： 最多可以缓存多少组件实例\n\nApp.vue\n\n\n\n\n6.额外的两个生命周期钩子#\n\nkeep-alive的使用会触发两个生命周期函数#\n\nactivated 当组件被激活（使用）的时候触发 → 进入这个页面的时候触发\n\ndeactivated 当组件不被使用的时候触发 → 离开这个页面的时候触发\n\n组件缓存后就不会执行组件的created, mounted, destroyed 等钩子了\n\n所以其提供了actived 和deactived钩子，帮我们实现业务需求。\n\n\n7.总结#\n\n1.keep-alive是什么\n\n2.keep-alive的优点\n\n3.keep-alive的三个属性 (了解)\n\n4.keep-alive的使用会触发两个生命周期函数(了解)\n\n\n二十二、VueCli 自定义创建项目#\n\n1.安装脚手架 (已安装)\n\n\n\n2.创建项目\n\n\n\n * 选项\n\n\n\n * 手动选择功能\n\n\n\n * 选择vue的版本\n\n\n\n * 是否使用history模式\n\n\n\n * 选择css预处理\n\n\n\n * 选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）\n * 比如：const age = 18; => 报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子\n\n\n\n * 选择校验的时机 （直接回车）\n\n\n\n * 选择配置文件的生成方式 （直接回车）\n\n\n\n * 是否保存预设，下次直接使用？ => 不保存，输入 N\n\n\n\n * 等待安装，项目初始化完成\n\n\n\n * 启动项目\n\n\n\n\n二十三、ESlint代码规范及手动修复#\n\n代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？...\n\n> 没有规矩不成方圆\n\nESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 JavaScript\nStandard Style 代码风格的规则。\n\n\n1.JavaScript Standard Style 规范说明#\n\n建议把：https://standardjs.com/rules-zhcn.html 看一遍，然后在写的时候, 遇到错误就查询解决。\n\n下面是这份规则中的一小部分：\n\n * 字符串使用单引号 – 需要转义的地方除外\n * 无分号 – 这没什么不好。不骗你！\n * 关键字后加空格 if (condition) { ... }\n * 函数名后加空格 function name (arg) { ... }\n * 坚持使用全等 === 摒弃 == 一但在需要检查 null || undefined 时可以使用 obj == null\n * ......\n\n2.代码规范错误#\n\n如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。\n\n下面我们在main.js中随意做一些改动：添加一些空行，空格。\n\n\n\n按下保存代码之后：\n\n你将会看在控制台中输出如下错误：\n\n\n\n> eslint 是来帮助你的。心态要好，有错，就改。\n\n3.手动修正#\n\n根据错误提示来一项一项手动修正。\n\n如果你不认识命令行中的语法报错是什么意思，你可以根据错误代码（func-call-spacing, space-in-parens,.....）去 ESLint\n规则列表中查找其具体含义。\n\n打开 ESLint 规则表，使用页面搜索（Ctrl - F）这个代码，查找对该规则的一个释义。\n\n\n\n\n二十四、通过eslint插件来实现自动修正#\n\n>  1. eslint会自动高亮错误显示\n>  2. 通过配置，eslint会自动帮助我们修复错误\n\n * 如何安装\n\n\n\n * 如何配置\n\n\n\n * 注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目\n * 注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify\n\nsettings.json 参考\n\n","routePath":"/vue/day06/day06","lang":"","toc":[{"text":"一、声明式导航-导航链接","id":"一声明式导航-导航链接","depth":2,"charIndex":3},{"text":"1.需求","id":"1需求","depth":3,"charIndex":19},{"text":"2.解决方案","id":"2解决方案","depth":3,"charIndex":90},{"text":"3.通过router-link自带的两个样式进行高亮","id":"3通过router-link自带的两个样式进行高亮","depth":3,"charIndex":230},{"text":"4.总结","id":"4总结","depth":3,"charIndex":378},{"text":"二、声明式导航-两个类名","id":"二声明式导航-两个类名","depth":2,"charIndex":447},{"text":"1.router-link-active","id":"1router-link-active","depth":3,"charIndex":489},{"text":"2.router-link-exact-active","id":"2router-link-exact-active","depth":3,"charIndex":591},{"text":"3.在地址栏中输入二级路由查看类名的添加","id":"3在地址栏中输入二级路由查看类名的添加","depth":3,"charIndex":647},{"text":"4.总结","id":"4总结-1","depth":3,"charIndex":671},{"text":"三、声明式导航-自定义类名（了解）","id":"三声明式导航-自定义类名了解","depth":2,"charIndex":718},{"text":"1.问题","id":"1问题","depth":3,"charIndex":739},{"text":"2.解决方案","id":"2解决方案-1","depth":3,"charIndex":784},{"text":"3.代码演示","id":"3代码演示","depth":3,"charIndex":862},{"text":"4.总结","id":"4总结-2","depth":3,"charIndex":874},{"text":"四、声明式导航-查询参数传参","id":"四声明式导航-查询参数传参","depth":2,"charIndex":907},{"text":"1.目标","id":"1目标","depth":3,"charIndex":925},{"text":"2.跳转传参","id":"2跳转传参","depth":3,"charIndex":998},{"text":"3.查询参数传参","id":"3查询参数传参","depth":3,"charIndex":1062},{"text":"4.代码演示","id":"4代码演示","depth":3,"charIndex":1133},{"text":"五、声明式导航-动态路由传参","id":"五声明式导航-动态路由传参","depth":2,"charIndex":1210},{"text":"1.动态路由传参方式","id":"1动态路由传参方式","depth":3,"charIndex":1228},{"text":"2.查询参数传参 VS 动态路由传参","id":"2查询参数传参-vs-动态路由传参","depth":3,"charIndex":1402},{"text":"3.总结","id":"3总结","depth":3,"charIndex":1667},{"text":"六、动态路由参数的可选符(了解)","id":"六动态路由参数的可选符了解","depth":2,"charIndex":1738},{"text":"1.问题","id":"1问题-1","depth":3,"charIndex":1758},{"text":"2.原因","id":"2原因","depth":3,"charIndex":1821},{"text":"七、Vue路由-重定向","id":"七vue路由-重定向","depth":2,"charIndex":1881},{"text":"1.问题","id":"1问题-2","depth":3,"charIndex":1896},{"text":"2.解决方案","id":"2解决方案-2","depth":3,"charIndex":1941},{"text":"3.语法","id":"3语法","depth":3,"charIndex":1980},{"text":"4.代码演示","id":"4代码演示-1","depth":3,"charIndex":1990},{"text":"八、Vue路由-404","id":"八vue路由-404","depth":2,"charIndex":2002},{"text":"1.作用","id":"1作用","depth":3,"charIndex":2017},{"text":"2.位置","id":"2位置","depth":3,"charIndex":2043},{"text":"3.语法","id":"3语法-1","depth":3,"charIndex":2092},{"text":"4.代码示例","id":"4代码示例","depth":3,"charIndex":2135},{"text":"九、Vue路由-模式设置","id":"九vue路由-模式设置","depth":2,"charIndex":2180},{"text":"1.问题","id":"1问题-3","depth":3,"charIndex":2196},{"text":"2.语法","id":"2语法","depth":3,"charIndex":2376},{"text":"十、编程式导航-两种路由跳转方式","id":"十编程式导航-两种路由跳转方式","depth":2,"charIndex":2386},{"text":"1.问题","id":"1问题-4","depth":3,"charIndex":2406},{"text":"2.方案","id":"2方案","depth":3,"charIndex":2429},{"text":"3.语法","id":"3语法-2","depth":3,"charIndex":2455},{"text":"4.path路径跳转语法","id":"4path路径跳转语法","depth":3,"charIndex":2523},{"text":"5.代码演示 path跳转方式","id":"5代码演示-path跳转方式","depth":3,"charIndex":2550},{"text":"6.name命名路由跳转","id":"6name命名路由跳转","depth":3,"charIndex":2569},{"text":"7.代码演示通过name命名路由跳转","id":"7代码演示通过name命名路由跳转","depth":3,"charIndex":2662},{"text":"8.总结","id":"8总结","depth":3,"charIndex":2684},{"text":"十一、编程式导航-path路径跳转传参","id":"十一编程式导航-path路径跳转传参","depth":2,"charIndex":2707},{"text":"1.问题","id":"1问题-5","depth":3,"charIndex":2730},{"text":"2.两种传参方式","id":"2两种传参方式","depth":3,"charIndex":2775},{"text":"3.传参","id":"3传参","depth":3,"charIndex":2805},{"text":"4.path路径跳转传参（query传参）","id":"4path路径跳转传参query传参","depth":3,"charIndex":2866},{"text":"5.path路径跳转传参（动态路由传参）","id":"5path路径跳转传参动态路由传参","depth":3,"charIndex":2922},{"text":"十二、编程式导航-name命名路由传参","id":"十二编程式导航-name命名路由传参","depth":2,"charIndex":3003},{"text":"1.name 命名路由跳转传参 (query传参)","id":"1name-命名路由跳转传参-query传参","depth":3,"charIndex":3026},{"text":"2.name 命名路由跳转传参 (动态路由传参)","id":"2name-命名路由跳转传参-动态路由传参","depth":3,"charIndex":3057},{"text":"3.总结","id":"3总结-1","depth":3,"charIndex":3087},{"text":"十三、面经基础版-案例效果分析","id":"十三面经基础版-案例效果分析","depth":2,"charIndex":3224},{"text":"1.面经效果演示","id":"1面经效果演示","depth":3,"charIndex":3243},{"text":"2.功能分析","id":"2功能分析","depth":3,"charIndex":3255},{"text":"3.实现思路分析：配置路由-功能实现","id":"3实现思路分析配置路由-功能实现","depth":3,"charIndex":3358},{"text":"十四、面经基础版-一级路由配置","id":"十四面经基础版-一级路由配置","depth":2,"charIndex":3489},{"text":"十五、面经基础版-二级路由配置","id":"十五面经基础版-二级路由配置","depth":2,"charIndex":3561},{"text":"1.使用场景","id":"1使用场景","depth":3,"charIndex":3608},{"text":"2.语法","id":"2语法-1","depth":3,"charIndex":3652},{"text":"这些二级路由对应的组件渲染到哪个一级路由下，children就配置到哪个路由下边","id":"这些二级路由对应的组件渲染到哪个一级路由下children就配置到哪个路由下边","depth":3,"charIndex":3783},{"text":"3.代码实现","id":"3代码实现","depth":3,"charIndex":3892},{"text":"十六、面经基础版-二级导航高亮","id":"十六面经基础版-二级导航高亮","depth":2,"charIndex":3935},{"text":"1.实现思路","id":"1实现思路","depth":3,"charIndex":3954},{"text":"2.代码实现","id":"2代码实现","depth":3,"charIndex":4035},{"text":"十七、面经基础版-首页请求渲染","id":"十七面经基础版-首页请求渲染","depth":2,"charIndex":4059},{"text":"1.步骤分析","id":"1步骤分析","depth":3,"charIndex":4078},{"text":"2.代码实现","id":"2代码实现-1","depth":3,"charIndex":4165},{"text":"十八、面经基础版-查询参数传参","id":"十八面经基础版-查询参数传参","depth":2,"charIndex":4269},{"text":"1.说明","id":"1说明","depth":3,"charIndex":4288},{"text":"2.查询参数传参实现","id":"2查询参数传参实现","depth":3,"charIndex":4434},{"text":"十九、面经基础版-动态路由传参","id":"十九面经基础版-动态路由传参","depth":2,"charIndex":4484},{"text":"1.实现步骤","id":"1实现步骤","depth":3,"charIndex":4503},{"text":"2.代码实现","id":"2代码实现-2","depth":3,"charIndex":4542},{"text":"3.额外优化功能点-点击回退跳转到上一页","id":"3额外优化功能点-点击回退跳转到上一页","depth":3,"charIndex":4613},{"text":"二十、面经基础版-详情页渲染","id":"二十面经基础版-详情页渲染","depth":2,"charIndex":4658},{"text":"1.实现步骤分析","id":"1实现步骤分析","depth":3,"charIndex":4676},{"text":"2.代码实现","id":"2代码实现-3","depth":3,"charIndex":4737},{"text":"二十一、面经基础版-缓存组件","id":"二十一面经基础版-缓存组件","depth":2,"charIndex":4782},{"text":"1.问题","id":"1问题-6","depth":3,"charIndex":4800},{"text":"2.原因","id":"2原因-1","depth":3,"charIndex":4849},{"text":"3.解决方案","id":"3解决方案","depth":3,"charIndex":4998},{"text":"4.什么是keep-alive","id":"4什么是keep-alive","depth":3,"charIndex":5033},{"text":"5.keep-alive的三个属性","id":"5keep-alive的三个属性","depth":3,"charIndex":5248},{"text":"6.额外的两个生命周期钩子","id":"6额外的两个生命周期钩子","depth":3,"charIndex":5366},{"text":"keep-alive的使用会触发两个生命周期函数","id":"keep-alive的使用会触发两个生命周期函数","depth":4,"charIndex":5382},{"text":"7.总结","id":"7总结","depth":3,"charIndex":5577},{"text":"二十二、VueCli 自定义创建项目","id":"二十二vuecli-自定义创建项目","depth":2,"charIndex":5675},{"text":"二十三、ESlint代码规范及手动修复","id":"二十三eslint代码规范及手动修复","depth":2,"charIndex":6010},{"text":"1.JavaScript Standard Style 规范说明","id":"1javascript-standard-style-规范说明","depth":3,"charIndex":6197},{"text":"2.代码规范错误","id":"2代码规范错误","depth":4,"charIndex":6509},{"text":"3.手动修正","id":"3手动修正","depth":4,"charIndex":6660},{"text":"二十四、通过eslint插件来实现自动修正","id":"二十四通过eslint插件来实现自动修正","depth":2,"charIndex":6835}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"Vuex 概述","content":"#\n\n目标：明确Vuex是什么，应用场景以及优势\n\n\n1.是什么#\n\nVuex 是一个 Vue 的 状态管理工具，状态就是数据。\n\n大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据 个人信息数\n\n\n2.使用场景#\n\n * 某个状态 在 很多个组件 来使用 (个人信息)\n\n * 多个组件 共同维护 一份数据 (购物车)\n\n\n\n\n3.优势#\n\n * 共同维护一份数据，数据集中化管理\n * 响应式变化\n * 操作简洁 (vuex提供了一些辅助函数)\n\n\n\n\n4.注意#\n\n官方原文：\n\n * 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex\n * 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度 （数据的操作更便捷，数据的流动更清晰）\n\nVuex就像《近视眼镜》, 你自然会知道什么时候需要用它~\n\n\n二、需求: 多组件共享数据#\n\n目标：基于脚手架创建项目，构建 vuex 多组件数据共享环境\n\n\n\n效果是三个组件共享一份数据:\n\n * 任意一个组件都可以修改数据\n * 三个组件的数据是同步的\n\n\n1.创建项目#\n\n\n\n\n2.创建三个组件, 目录如下#\n\n\n\n\n3.源代码如下#\n\nApp.vue在入口组件中引入 Son1 和 Son2 这两个子组件\n\n\n\nmain.js\n\n\n\nSon1.vue\n\n\n\nSon2.vue\n\n\n\n\n三、vuex 的使用 - 创建仓库#\n\n\n\n\n1.安装 vuex#\n\n安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。\n\n\n\n\n2.新建 store/index.js 专门存放 vuex#\n\n为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 router/index.js 类似)\n\n\n\n\n3.创建仓库 store/index.js#\n\n\n\n\n4 在 main.js 中导入挂载到 Vue 实例上#\n\n\n\n此刻起, 就成功创建了一个 空仓库!!\n\n\n5.测试打印Vuex#\n\nApp.vue\n\n\n\n\n四、核心概念 - state 状态#\n\n\n1.目标#\n\n明确如何给仓库 提供 数据，如何 使用 仓库的数据\n\n\n2.提供数据#\n\nState提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。\n\n打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。\n\n\n\n\n3.访问Vuex中的数据#\n\n问题: 如何在组件中获取count?\n\n 1. 通过$store直接访问 —> {{ $store.state.count }}\n 2. 通过辅助函数mapState 映射计算属性 —> {{ count }}\n\n\n4.通过$store访问的语法#\n\n\n\n\n5.代码实现#\n\n5.1模板中使用#\n\n组件中可以使用 $store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下\n\n\n\n5.2组件逻辑中使用#\n\n将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html\n\n\n\n5.3 js文件中使用#\n\n\n\n每次都像这样一个个的提供计算属性, 太麻烦了,我们有没有简单的语法帮我们获取state中的值呢？\n\n\n五、通过辅助函数 - mapState获取 state中的数据#\n\n> mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法\n\n用法 ：\n\n\n\n\n1.第一步：导入mapState (mapState是vuex中的一个函数)#\n\n\n\n\n2.第二步：采用数组形式引入state属性#\n\n\n\n> 上面代码的最终得到的是 类似于\n\n\n\n\n3.第三步：利用展开运算符将导出的状态映射给计算属性#\n\n\n\n\n\n\n六、开启严格模式及Vuex的单项数据流#\n\n\n1.目标#\n\n明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据\n\n\n2.直接在组件中修改Vuex中state的值#\n\n\n\nSon1.vue\n\n\n\n\n3.开启严格模式#\n\n通过 strict: true 可以开启严格模式,开启严格模式后，直接修改state中的值会报错\n\n> state数据的修改只能通过mutations，并且mutations必须是同步的\n\n\n\n\n七、核心概念-mutations#\n\n\n1.定义mutations#\n\n\n\n\n2.格式说明#\n\nmutations是一个对象，对象中存放修改state的方法\n\n\n\n\n3.组件中提交 mutations#\n\n\n\n\n4.练习#\n\n1.在mutations中定义个点击按钮进行 -5 的方法\n\n2.在mutations中定义个点击按钮进行 改变title 的方法\n\n3.在组件中调用mutations修改state中的值\n\n\n5.总结#\n\n通过mutations修改state的步骤\n\n1.定义 mutations 对象，对象中存放修改 state 的方法\n\n2.组件中提交调用 mutations(通过$store.commit('mutations的方法名'))\n\n\n八、带参数的 mutations#\n\n\n1.目标#\n\n掌握 mutations 传参语法\n\n\n2.语法#\n\n看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？\n\n\n\n提交 mutation 是可以传递参数的 this.$store.commit('xxx', 参数)\n\n2.1 提供mutation函数（带参数）#\n\n\n\n2.2 提交mutation#\n\n\n\n小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象\n\n\n\n\n九、练习-mutations的减法功能#\n\n\n\n\n1.步骤#\n\n\n\n\n2.代码实现#\n\nSon2.vue\n\n\n\nstore/index.js\n\n\n\n\n十、练习-Vuex中的值和组件中的input双向绑定#\n\n\n1.目标#\n\n实时输入，实时更新，巩固 mutations 传参语法\n\n\n\n\n2.实现步骤#\n\n\n\n\n3.代码实现#\n\nApp.vue\n\n\n\nstore/index.js\n\n\n\n\n十一、辅助函数- mapMutations#\n\n> mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入\n\n\n\n> 上面代码的含义是将mutations的方法导入了methods中，等价于\n\n\n\n此时，就可以直接通过this.addCount调用了\n\n\n\n但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中\n\n\n十二、核心概念 - actions#\n\n> state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，\n> \n> actions则负责进行异步操作\n\n说明：mutations必须是同步的\n\n需求: 一秒钟之后, 要给一个数 去修改state\n\n\n\n\n1.定义actions#\n\n\n\n\n2.组件中通过dispatch调用#\n\n\n\n\n\n\n十三、辅助函数 -mapActions#\n\n1.目标：掌握辅助函数 mapActions，映射方法\n\n> mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中\n\nSon2.vue\n\n\n\n直接通过 this.方法 就可以调用\n\n\n\n\n十四、核心概念 - getters#\n\n> 除了state之外，有时我们还需要从state中筛选出符合条件的一些数据，这些数据是依赖state的，此时会用到getters\n\n例如，state中定义了list，为1-10的数组，\n\n\n\n组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它\n\n\n1.定义getters#\n\n\n\n\n2.使用getters#\n\n2.1原始方式-$store#\n\n\n\n2.2辅助函数 - mapGetters#\n\n\n\n\n\n\n十五、使用小结#\n\n\n\n\n十六、核心概念 - module#\n\n\n1.目标#\n\n掌握核心概念 module 模块的创建\n\n\n2.问题#\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护\n\n由此，又有了Vuex的模块化\n\n\n\n\n3.模块定义 - 准备 state#\n\n定义两个模块 user 和 setting\n\nuser中管理用户的信息状态 userInfo modules/user.js\n\n\n\nsetting中管理项目应用的 主题色 theme，描述 desc， modules/setting.js\n\n\n\n在store/index.js文件中的modules配置项中，注册这两个模块\n\n\n\n使用模块中的数据, 可以直接通过模块名访问 $store.state.模块名.xxx => $store.state.setting.desc\n\n也可以通过 mapState 映射\n\n\n十七、获取模块内的state数据#\n\n\n1.目标#\n\n掌握模块中 state 的访问语法\n\n尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名\n\n\n\n\n2.使用模块中的数据#\n\n 1. 直接通过模块名访问 $store.state.模块名.xxx\n 2. 通过 mapState 映射：\n    1. 默认根级别的映射 mapState([ 'xxx' ])\n    2. 子模块的映射 ：mapState('模块名', ['xxx']) - 需要开启命名空间 namespaced:true\n\nmodules/user.js\n\n\n\n\n3.代码示例#\n\n$store直接访问\n\n\n\nmapState辅助函数访问\n\n\n\n\n十八、获取模块内的getters数据#\n\n\n1.目标#\n\n掌握模块中 getters 的访问语\n\n\n2.语法#\n\n使用模块中 getters 中的数据:\n\n 1. 直接通过模块名访问$store.getters['模块名/xxx ']\n 2. 通过 mapGetters 映射\n    1. 默认根级别的映射mapGetters([ 'xxx' ])\n    2. 子模块的映射mapGetters('模块名', ['xxx']) - 需要开启命名空间\n\n\n3.代码演示#\n\nmodules/user.js\n\n\n\nSon1.vue 直接访问getters\n\n\n\nSon2.vue 通过命名空间访问\n\n\n\n\n十九、获取模块内的mutations方法#\n\n\n1.目标#\n\n掌握模块中 mutation 的调用语法\n\n\n2.注意#\n\n默认模块中的 mutation 和 actions 会被挂载到全局，需要开启命名空间，才会挂载到子模块。\n\n\n3.调用方式#\n\n 1. 直接通过 store 调用 $store.commit('模块名/xxx ', 额外参数)\n 2. 通过 mapMutations 映射\n    1. 默认根级别的映射 mapMutations([ 'xxx' ])\n    2. 子模块的映射 mapMutations('模块名', ['xxx']) - 需要开启命名空间\n\n\n4.代码实现#\n\nmodules/user.js\n\n\n\nmodules/setting.js\n\n\n\nSon1.vue\n\n\n\nSon2.vue\n\n\n\n\n二十、获取模块内的actions方法#\n\n\n1.目标#\n\n掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)\n\n\n2.注意#\n\n默认模块中的 mutation 和 actions 会被挂载到全局，需要开启命名空间，才会挂载到子模块。\n\n\n3.调用语法#\n\n 1. 直接通过 store 调用 $store.dispatch('模块名/xxx ', 额外参数)\n 2. 通过 mapActions 映射\n    1. 默认根级别的映射 mapActions([ 'xxx' ])\n    2. 子模块的映射 mapActions('模块名', ['xxx']) - 需要开启命名空间\n\n\n4.代码实现#\n\n需求：\n\n\n\nmodules/user.js\n\n\n\nSon1.vue 直接通过store调用\n\n\n\nSon2.vue mapActions映射\n\n\n\n\n二十一、Vuex模块化的使用小结#\n\n\n1.直接使用#\n\n 1. state --> $store.state.模块名.数据项名\n 2. getters --> $store.getters['模块名/属性名']\n 3. mutations --> $store.commit('模块名/方法名', 其他参数)\n 4. actions --> $store.dispatch('模块名/方法名', 其他参数)\n\n\n2.借助辅助方法使用#\n\n 1. \n\ncomputed、methods: {\n\n// ...mapState、...mapGetters放computed中；\n\n// ...mapMutations、...mapActions放methods中；\n\n...mapXxxx('模块名', ['数据项|方法']),\n\n...mapXxxx('模块名', { 新的名字: 原来的名字 }),\n\n}\n\n2.组件中直接使用 属性 {{ age }} 或 方法 @click=\"updateAge(2)\"\n\n\n二十二、综合案例 - 创建项目#\n\n 1. 脚手架新建项目 (注意：勾选vuex)\n    \n    版本说明：\n    \n    vue2 vue-router3 vuex3\n    \n    vue3 vue-router4 vuex4/pinia\n\n\n\n 1. 将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》\n\n\n\n需求：\n\n 1. 发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块...）\n 2. 数字框可以修改数据\n 3. 动态计算总价和总数量\n\n\n二十三、综合案例-构建vuex-cart模块#\n\n 1. 新建 store/modules/cart.js\n    \n    \n\n 2. 挂载到 vuex 仓库上store/cart.js\n    \n    \n\n\n二十四、综合案例-准备后端接口服务环境(了解)#\n\n 1. 安装全局工具 json-server （全局工具仅需要安装一次）\n    \n    \n\n 2. 代码根目录新建一个 db 目录\n\n 3. 将资料 index.json 移入 db 目录\n\n 4. 进入 db 目录，执行命令，启动后端接口服务 (使用--watch 参数 可以实时监听 json 文件的修改)\n\n\n\n\n二十五、综合案例-请求动态渲染数据#\n\n\n1.目标#\n\n请求获取数据存入 vuex, 映射渲染\n\n\n\n 1. 安装 axios\n    \n    \n\n 2. 准备actions 和 mutations\n    \n    \n\n 3. App.vue页面中调用 action, 获取数据\n    \n    \n\n 4. 动态渲染\n    \n    \n    \n    cart-item.vue\n    \n    \n\n\n二十六、综合案例-修改数量#\n\n\n\n 1. 注册点击事件\n    \n    \n\n 2. 页面中dispatch action\n    \n    \n\n 3. 提供action函数\n    \n    \n\n 4. 提供mutation处理函数\n    \n    \n\n\n二十七、综合案例-底部总价展示#\n\n 1. 提供getters\n    \n    \n\n 2. 动态渲染\n    \n    ","routePath":"/vue/day07/day07","lang":"","toc":[{"text":"1.是什么","id":"1是什么","depth":2,"charIndex":26},{"text":"2.使用场景","id":"2使用场景","depth":2,"charIndex":126},{"text":"3.优势","id":"3优势","depth":2,"charIndex":191},{"text":"4.注意","id":"4注意","depth":2,"charIndex":255},{"text":"二、需求: 多组件共享数据","id":"二需求-多组件共享数据","depth":2,"charIndex":395},{"text":"1.创建项目","id":"1创建项目","depth":3,"charIndex":495},{"text":"2.创建三个组件, 目录如下","id":"2创建三个组件-目录如下","depth":3,"charIndex":507},{"text":"3.源代码如下","id":"3源代码如下","depth":3,"charIndex":527},{"text":"三、vuex 的使用 - 创建仓库","id":"三vuex-的使用---创建仓库","depth":2,"charIndex":611},{"text":"1.安装 vuex","id":"1安装-vuex","depth":3,"charIndex":634},{"text":"2.新建 `store/index.js` 专门存放 vuex","id":"2新建-storeindexjs-专门存放-vuex","depth":3,"charIndex":-1},{"text":"3.创建仓库 `store/index.js`","id":"3创建仓库-storeindexjs","depth":3,"charIndex":-1},{"text":"4 在 main.js 中导入挂载到 Vue 实例上","id":"4-在-mainjs-中导入挂载到-vue-实例上","depth":3,"charIndex":845},{"text":"5.测试打印Vuex","id":"5测试打印vuex","depth":3,"charIndex":898},{"text":"四、核心概念 - state 状态","id":"四核心概念---state-状态","depth":2,"charIndex":923},{"text":"1.目标","id":"1目标","depth":3,"charIndex":944},{"text":"2.提供数据","id":"2提供数据","depth":3,"charIndex":979},{"text":"3.访问Vuex中的数据","id":"3访问vuex中的数据","depth":3,"charIndex":1079},{"text":"4.通过$store访问的语法","id":"4通过store访问的语法","depth":3,"charIndex":1202},{"text":"5.代码实现","id":"5代码实现","depth":3,"charIndex":1223},{"text":"5.1模板中使用","id":"51模板中使用","depth":4,"charIndex":1232},{"text":"5.2组件逻辑中使用","id":"52组件逻辑中使用","depth":4,"charIndex":1304},{"text":"5.3 js文件中使用","id":"53-js文件中使用","depth":4,"charIndex":1380},{"text":"五、通过辅助函数  - mapState获取 state中的数据","id":"五通过辅助函数----mapstate获取-state中的数据","depth":2,"charIndex":-1},{"text":"1.第一步：导入mapState (mapState是vuex中的一个函数)","id":"1第一步导入mapstate-mapstate是vuex中的一个函数","depth":3,"charIndex":1546},{"text":"2.第二步：采用数组形式引入state属性","id":"2第二步采用数组形式引入state属性","depth":3,"charIndex":1590},{"text":"3.第三步：利用**展开运算符**将导出的状态映射给计算属性","id":"3第三步利用展开运算符将导出的状态映射给计算属性","depth":3,"charIndex":-1},{"text":"六、开启严格模式及Vuex的单项数据流","id":"六开启严格模式及vuex的单项数据流","depth":2,"charIndex":1672},{"text":"1.目标","id":"1目标-1","depth":3,"charIndex":1695},{"text":"2.直接在组件中修改Vuex中state的值","id":"2直接在组件中修改vuex中state的值","depth":3,"charIndex":1737},{"text":"3.开启严格模式","id":"3开启严格模式","depth":3,"charIndex":1777},{"text":"七、核心概念-mutations","id":"七核心概念-mutations","depth":2,"charIndex":1886},{"text":"1.定义mutations","id":"1定义mutations","depth":3,"charIndex":1906},{"text":"2.格式说明","id":"2格式说明","depth":3,"charIndex":1925},{"text":"3.组件中提交 mutations","id":"3组件中提交-mutations","depth":3,"charIndex":1969},{"text":"4.练习","id":"4练习","depth":3,"charIndex":1992},{"text":"5.总结","id":"5总结","depth":3,"charIndex":2096},{"text":"八、带参数的 mutations","id":"八带参数的-mutations","depth":2,"charIndex":2219},{"text":"1.目标","id":"1目标-2","depth":3,"charIndex":2239},{"text":"2.语法","id":"2语法","depth":3,"charIndex":2266},{"text":"2.1 提供mutation函数（带参数）","id":"21-提供mutation函数带参数","depth":4,"charIndex":2376},{"text":"2.2 提交mutation","id":"22-提交mutation","depth":4,"charIndex":2402},{"text":"九、练习-mutations的减法功能","id":"九练习-mutations的减法功能","depth":2,"charIndex":2464},{"text":"1.步骤","id":"1步骤","depth":3,"charIndex":2489},{"text":"2.代码实现","id":"2代码实现","depth":3,"charIndex":2499},{"text":"十、练习-Vuex中的值和组件中的input双向绑定","id":"十练习-vuex中的值和组件中的input双向绑定","depth":2,"charIndex":2539},{"text":"1.目标","id":"1目标-3","depth":3,"charIndex":2569},{"text":"2.实现步骤","id":"2实现步骤","depth":3,"charIndex":2608},{"text":"3.代码实现","id":"3代码实现","depth":3,"charIndex":2620},{"text":"十一、辅助函数- mapMutations","id":"十一辅助函数--mapmutations","depth":2,"charIndex":2659},{"text":"十二、核心概念 - actions","id":"十二核心概念---actions","depth":2,"charIndex":2877},{"text":"**1.定义actions**","id":"1定义actions","depth":3,"charIndex":-1},{"text":"**2.组件中通过dispatch调用**","id":"2组件中通过dispatch调用","depth":3,"charIndex":-1},{"text":"十三、辅助函数 -mapActions","id":"十三辅助函数--mapactions","depth":2,"charIndex":3076},{"text":"十四、核心概念 - getters","id":"十四核心概念---getters","depth":2,"charIndex":3212},{"text":"1.定义getters","id":"1定义getters","depth":3,"charIndex":3393},{"text":"2.使用getters","id":"2使用getters","depth":3,"charIndex":3410},{"text":"2.1原始方式-$store","id":"21原始方式-store","depth":4,"charIndex":3424},{"text":"2.2辅助函数 - mapGetters","id":"22辅助函数---mapgetters","depth":4,"charIndex":3443},{"text":"十五、使用小结","id":"十五使用小结","depth":2,"charIndex":3471},{"text":"十六、核心概念 - module","id":"十六核心概念---module","depth":2,"charIndex":3484},{"text":"1.目标","id":"1目标-4","depth":3,"charIndex":3504},{"text":"2.问题","id":"2问题","depth":3,"charIndex":3533},{"text":"**3.模块定义** - 准备 state","id":"3模块定义---准备-state","depth":3,"charIndex":-1},{"text":"十七、获取模块内的state数据","id":"十七获取模块内的state数据","depth":2,"charIndex":3954},{"text":"1.目标","id":"1目标-5","depth":3,"charIndex":3974},{"text":"2.使用模块中的数据","id":"2使用模块中的数据","depth":3,"charIndex":4050},{"text":"3.代码示例","id":"3代码示例","depth":3,"charIndex":4242},{"text":"十八、获取模块内的getters数据","id":"十八获取模块内的getters数据","depth":2,"charIndex":4284},{"text":"1.目标","id":"1目标-6","depth":3,"charIndex":4306},{"text":"2.语法","id":"2语法-1","depth":3,"charIndex":4334},{"text":"3.代码演示","id":"3代码演示","depth":3,"charIndex":4513},{"text":"十九、获取模块内的mutations方法","id":"十九获取模块内的mutations方法","depth":2,"charIndex":4587},{"text":"1.目标","id":"1目标-7","depth":3,"charIndex":4611},{"text":"2.注意","id":"2注意","depth":3,"charIndex":4641},{"text":"3.调用方式","id":"3调用方式","depth":3,"charIndex":4703},{"text":"4.代码实现","id":"4代码实现","depth":3,"charIndex":4881},{"text":"二十、获取模块内的actions方法","id":"二十获取模块内的actions方法","depth":2,"charIndex":4956},{"text":"1.目标","id":"1目标-8","depth":3,"charIndex":4978},{"text":"2.注意","id":"2注意-1","depth":3,"charIndex":5030},{"text":"3.调用语法","id":"3调用语法","depth":3,"charIndex":5092},{"text":"4.代码实现","id":"4代码实现-1","depth":3,"charIndex":5266},{"text":"二十一、Vuex模块化的使用小结","id":"二十一vuex模块化的使用小结","depth":2,"charIndex":5351},{"text":"1.直接使用","id":"1直接使用","depth":3,"charIndex":5371},{"text":"2.借助辅助方法使用","id":"2借助辅助方法使用","depth":3,"charIndex":5558},{"text":"二十二、综合案例 - 创建项目","id":"二十二综合案例---创建项目","depth":2,"charIndex":5807},{"text":"二十三、综合案例-构建vuex-cart模块","id":"二十三综合案例-构建vuex-cart模块","depth":2,"charIndex":6075},{"text":"二十四、综合案例-准备后端接口服务环境(了解)","id":"二十四综合案例-准备后端接口服务环境了解","depth":2,"charIndex":6182},{"text":"二十五、综合案例-请求动态渲染数据","id":"二十五综合案例-请求动态渲染数据","depth":2,"charIndex":6370},{"text":"1.目标","id":"1目标-9","depth":3,"charIndex":6391},{"text":"二十六、综合案例-修改数量","id":"二十六综合案例-修改数量","depth":2,"charIndex":6577},{"text":"二十七、综合案例-底部总价展示","id":"二十七综合案例-底部总价展示","depth":2,"charIndex":6708}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"智慧商城","content":"#\n\n接口文档：https://apifox.com/apidoc/shared-12ab6b18-adc2-444c-ad11-0e60f5693f66/doc-2\n221080\n\n演示地址：http://cba.itlike.com/public/mweb/#/\n\n\n01. 项目功能演示#\n\n\n1.明确功能模块#\n\n启动准备好的代码，演示移动端面经内容，明确功能模块\n\n\n\n\n2.项目收获#\n\n\n\n\n02. 项目创建目录初始化#\n\n\nvue-cli 建项目#\n\n1.安装脚手架 (已安装)\n\n\n\n2.创建项目\n\n\n\n * 选项\n\n\n\n * 手动选择功能\n\n\n\n * 选择vue的版本\n\n\n\n * 是否使用history模式\n\n\n\n * 选择css预处理\n\n\n\n * 选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）\n * 比如：const age = 18; => 报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子\n\n\n\n * 选择校验的时机 （直接回车）\n\n\n\n * 选择配置文件的生成方式 （直接回车）\n\n\n\n * 是否保存预设，下次直接使用？ => 不保存，输入 N\n\n\n\n * 等待安装，项目初始化完成\n\n\n\n * 启动项目\n\n\n\n\n03. 调整初始化目录结构#\n\n> 强烈建议大家严格按照老师的步骤进行调整，为了符合企业规范\n\n为了更好的实现后面的操作，我们把整体的目录结构做一些调整。\n\n目标:\n\n 1. 删除初始化的一些默认文件\n 2. 修改没删除的文件\n 3. 新增我们需要的目录结构\n\n\n1.删除文件#\n\n * src/./assets/logo.png\n * src/components/HelloWorld.vue\n * src/views/AboutView.vue\n * src/views/HomeView.vue\n\n\n2.修改文件#\n\nmain.js 不需要修改\n\nrouter/index.js\n\n删除默认的路由配置\n\n\n\nApp.vue\n\n\n\n\n3.新增目录#\n\n * src/api 目录\n   * 存储接口模块 (发送ajax请求接口的模块)\n * src/utils 目录\n   * 存储一些工具模块 (自己封装的方法)\n\n目录效果如下:\n\n\n\n\n04. vant组件库及Vue周边的其他组件库#\n\n> 组件库：第三方封装好了很多很多的组件，整合到一起就是一个组件库。\n> \n> https://vant-contrib.gitee.io/vant/v2/#/zh-CN/\n\n\n\n比如日历组件、键盘组件、打分组件、下拉筛选组件等\n\n组件库并不是唯一的，常用的组件库还有以下几种：\n\npc: element-ui element-plus iview ant-design\n\n移动：vant-ui Mint UI (饿了么) Cube UI (滴滴)\n\n\n05. 全部导入和按需导入的区别#\n\n目标：明确 全部导入 和 按需导入 的区别\n\n\n\n区别：\n\n1.全部导入会引起项目打包后的体积变大，进而影响用户访问网站的性能\n\n2.按需导入只会导入你使用的组件，进而节约了资源\n\n\n06. 全部导入#\n\n * 安装vant-ui\n\n\n\n * 在main.js中\n\n\n\n * 即可使用\n\n\n\n\n\nvant-ui提供了很多的组件，全部导入，会导致项目打包变得很大。\n\n\n07. 按需导入#\n\n * 安装vant-ui\n\n\n\n * 安装一个插件\n\n\n\n * 在babel.config.js中配置\n\n\n\n * 按需加载，在main.js\n\n\n\n * app.vue中进行测试\n\n\n\n * 把引入组件的步骤抽离到单独的js文件中比如 utils/vant-ui.js\n\n\n\nmain.js中进行导入\n\n\n\n\n08. 项目中的vw适配#\n\n官方说明：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/advanced-usage\n\n\n\n * 项目根目录， 新建postcss的配置文件postcss.config.js\n\n\n\nviewportWidth:设计稿的视口宽度\n\n 1. vant-ui中的组件就是按照375的视口宽度设计的\n 2. 恰好面经项目中的设计稿也是按照375的视口宽度设计的，所以此时 我们只需要配置375就可以了\n 3. 如果设计稿不是按照375而是按照750的宽度设计，那此时这个值该怎么填呢？\n\n\n09. 路由配置 - 一级路由#\n\n但凡是单个页面，独立展示的，都是一级路由\n\n路由设计：\n\n * 登录页\n * 首页架子\n   * 首页 - 二级\n   * 分类页 - 二级\n   * 购物车 - 二级\n   * 我的 - 二级\n * 搜索页\n * 搜索列表页\n * 商品详情页\n * 结算支付页\n * 我的订单页\n\nrouter/index.js 配置一级路由，新建对应的页面文件\n\n\n\n\n10. 路由配置-tabbar标签页#\n\n\n\nhttps://vant-contrib.gitee.io/vant/v2/#/zh-CN/tabbar\n\nvant-ui.js 引入组件\n\n\n\nlayout.vue\n\n 1. 复制官方代码\n 2. 修改显示文本及显示的图标\n 3. 配置高亮颜色\n\n\n\n\n11. 路由配置 - 二级路由#\n\n 1. router/index.js配置二级路由\n    \n    \n\n 2. 准备对应的组件文件\n    \n    * layout/home.vue\n    * layout/category.vue\n    * layout/cart.vue\n    * layout/user.vue\n\n 3. layout.vue 配置路由出口, 配置 tabbar\n    \n    \n\n\n12. 登录页静态布局#\n\n\n(1) 准备工作#\n\n 1. 新建 styles/common.less 重置默认样式\n    \n    \n\n 2. main.js 中导入应用\n    \n    \n\n 3. 将准备好的一些图片素材拷贝到 ./assets 目录【备用】\n\n\n\n\n(2) 登录静态布局#\n\n\n\n使用组件\n\n * van-nav-bar\n\nvant-ui.js 注册\n\n\n\nLogin.vue 使用\n\n\n\n添加通用样式\n\nstyles/common.less 设置导航条，返回箭头颜色\n\n\n\n\n13. request模块 - axios封装#\n\n接口文档：https://apifox.com/apidoc/shared-12ab6b18-adc2-444c-ad11-0e60f5693f66/doc-2\n221080\n\n演示地址：http://cba.itlike.com/public/mweb/#/\n\n基地址：http://cba.itlike.com/public/index.php?s=/api/\n\n我们会使用 axios 来请求后端接口, 一般都会对 axios 进行一些配置 (比如: 配置基础地址,请求响应拦截器等等)\n\n一般项目开发中, 都会对 axios 进行基本的二次封装, 单独封装到一个模块中, 便于使用\n\n目标：将 axios 请求方法，封装到 request 模块\n\n 1. 安装 axios\n    \n    \n\n 2. 新建 utils/request.js 封装 axios 模块\n    \n    利用 axios.create 创建一个自定义的 axios 来使用\n    http://www.axios-js.com/zh-cn/docs/#axios-create-config\n    \n    \n\n 3. 获取图形验证码，请求测试\n    \n    \n\n\n\n\n14. 图形验证码功能完成#\n\n\n\n 1. 准备数据，获取图形验证码后存储图片路径，存储图片唯一标识\n    \n    \n\n 2. 动态渲染图形验证码，并且点击时要重新刷新验证码\n    \n    \n\n\n15. 封装api接口 - 图片验证码接口#\n\n**1.目标：**将请求封装成方法，统一存放到 api 模块，与页面分离\n\n2.原因：以前的模式\n\n\n\n * 页面中充斥着请求代码\n\n * 可阅读性不高\n\n * 相同的请求没有复用请求没有统一管理\n\n3.期望：\n\n\n\n * 请求与页面逻辑分离\n * 相同的请求可以直接复用请求\n * 进行了统一管理\n\n4.具体实现\n\n新建 api/login.js 提供获取图形验证码 Api 函数\n\n\n\nlogin/index.vue页面中调用测试\n\n\n\n\n16. toast 轻提示#\n\nhttps://vant-contrib.gitee.io/vant/v2/#/zh-CN/toast\n\n两种使用方式\n\n 1. 导入调用 ( 组件内 或 非组件中均可 )\n    \n    \n\n 2. 通过this直接调用 ( 组件内)\n    \n    main.js 注册绑定到原型\n    \n    \n    \n    \n\n\n17. 短信验证倒计时功能#\n\n\n\n\n(1) 倒计时基础效果#\n\n 1. 准备 data 数据\n    \n    \n\n 2. 给按钮注册点击事件\n    \n    \n\n 3. 开启倒计时时\n    \n    \n\n 4. 离开页面销毁定时器\n    \n    \n\n\n(2) 验证码请求校验处理#\n\n 1. 输入框 v-model 绑定变量\n    \n    \n\n 2. methods中封装校验方法\n    \n    \n\n 3. 请求倒计时前进行校验\n    \n    \n\n\n(3) 封装接口，请求获取验证码#\n\n 1. 封装接口 api/login.js\n    \n    \n\n 2. 调用接口，添加提示\n    \n    \n\n\n18. 封装api接口 - 登录功能#\n\napi/login.js 提供登录 Api 函数\n\n\n\nlogin/index.vue 登录功能\n\n\n\n\n19. 响应拦截器统一处理错误提示#\n\n响应拦截器是咱们拿到数据的 第一个 “数据流转站”，可以在里面统一处理错误，只要不是 200 默认给提示，抛出错误\n\nutils/request.js\n\n\n\n\n20. 将登录权证信息存入 vuex#\n\n 1. 新建 vuex user 模块 store/modules/user.js\n    \n    \n\n 2. 挂载到 vuex 上\n    \n    \n\n 3. 提供 mutations\n    \n    \n\n 4. 页面中 commit 调用\n    \n    \n\n\n21. vuex持久化处理#\n\n 1. 新建 utils/storage.js 封装方法\n    \n    \n\n 2. vuex user 模块持久化处理\n    \n    \n\n\n22. 优化：添加请求 loading 效果#\n\n 1. 请求时，打开 loading\n    \n    \n\n 2. 响应时，关闭 loading\n    \n    \n\n\n23. 登录访问拦截 - 路由前置守卫#\n\n目标：基于全局前置守卫，进行页面访问拦截处理\n\n说明：智慧商城项目，大部分页面，游客都可以直接访问, 如遇到需要登录才能进行的操作，提示并跳转到登录\n\n但是：对于支付页，订单页等，必须是登录的用户才能访问的，游客不能进入该页面，需要做拦截处理\n\n\n\n路由导航守卫 - 全局前置守卫\n\n1.所有的路由一旦被匹配到，都会先经过全局前置守卫\n\n2.只有全局前置守卫放行，才会真正解析渲染组件，才能看到页面内容\n\n\n\n\n\n\n\n\n24. 首页 - 静态结构准备#\n\n\n\n 1. 静态结构和样式 layout/home.vue\n    \n    \n\n 2. 新建components/GoodsItem.vue\n    \n    \n\n 3. 组件按需引入\n    \n    \n\n\n25. 首页 - 动态渲染#\n\n 1. 封装准备接口 api/home.js\n    \n    \n\n 2. 页面中请求调用\n    \n    \n\n 3. 轮播图、导航、猜你喜欢渲染\n    \n    \n\n 4. 商品组件内，动态渲染\n    \n    \n\n\n26. 搜索 - 静态布局准备#\n\n\n\n 1. 静态结构和代码\n    \n    \n\n 2. 组件按需导入\n    \n    \n\n\n27. 搜索 - 历史记录 - 基本管理#\n\n 1. data 中提供数据，和搜索框双向绑定 (实时获取用户内容)\n    \n    \n\n 2. 准备假数据，进行基本的历史纪录渲染\n    \n    \n\n 3. 点击搜索，或者下面搜索历史按钮，都要进行搜索历史记录更新 (去重，新搜索的内容置顶)\n    \n    \n\n 4. 清空历史\n    \n    \n\n\n28. 搜索 - 历史记录 - 持久化#\n\n 1. 持久化到本地 - 封装方法\n    \n    \n\n 2. 页面中调用 - 实现持久化\n    \n    \n\n\n29. 搜索列表 - 静态布局#\n\n\n\n\n\n\n30. 搜索列表 - 动态渲染#\n\n\n(1) 搜索关键字搜索#\n\n 1. 计算属性，基于query 解析路由参数\n    \n    \n\n 2. 根据不同的情况，设置输入框的值\n    \n    \n\n 3. api/product.js 封装接口，获取搜索商品\n    \n    \n\n 4. 页面中基于 goodsName 发送请求，动态渲染\n    \n    \n\n\n(2) 分类id搜索#\n\n 1. 封装接口 api/category.js\n    \n    \n\n 2. 分类页静态结构\n    \n    \n\n 3. 搜索页，基于分类 ID 请求\n    \n    \n\n\n31. 商品详情 - 静态布局#\n\n静态结构 和 样式\n\n\n\nLazyload 是 Vue 指令，使用前需要对指令进行注册。\n\n\n\n\n32. 商品详情 - 动态渲染介绍#\n\n 1. 动态路由参数，获取商品 id\n    \n    \n\n 2. 封装 api 接口 api/product.js\n    \n    \n\n 3. 一进入页面发送请求，获取商品详情数据\n    \n    \n\n 4. 动态渲染\n    \n    \n\n\n33. 商品详情 - 动态渲染评价#\n\n 1. 封装接口 api/product.js\n    \n    \n\n 2. 页面调用获取数据\n    \n    \n\n 3. 动态渲染评价\n    \n    \n\n\n34. 加入购物车 - 唤起弹窗#\n\n\n\n 1. 按需导入 van-action-sheet\n    \n    \n\n 2. 准备 van-action-sheet 基本结构\n    \n    \n\n 3. 注册点击事件，点击时唤起弹窗\n    \n    \n\n 4. 完善结构\n    \n    \n    \n    \n\n 5. 动态渲染\n    \n    \n\n\n35. 加入购物车 - 封装数字框组件#\n\n\n\n 1. 封装组件 components/CountBox.vue\n    \n    \n\n 2. 使用组件\n    \n    \n\n\n36. 加入购物车 - 判断 token 登录提示#\n\n说明：加入购物车，是一个登录后的用户才能进行的操作，所以需要进行鉴权判断，判断用户 token 是否存在\n\n 1. 若存在：继续加入购物车操作\n 2. 不存在：提示用户未登录，引导到登录页\n\n\n\n 1. 按需注册 dialog 组件\n    \n    \n\n 2. 按钮注册点击事件\n    \n    \n\n 3. 添加 token 鉴权判断，跳转携带回跳地址\n    \n    \n\n 4. 登录后，若有回跳地址，则回跳页面\n    \n    \n\n\n37. 加入购物车 - 封装接口进行请求#\n\n\n\n 1. 封装接口 api/cart.js\n    \n    \n\n 2. 页面中调用请求\n    \n    \n    \n    \n\n 3. 请求拦截器中，统一携带 token\n    \n    \n\n 4. 准备小图标\n    \n    \n\n 5. 定制样式\n    \n    \n\n\n38. 购物车 - 静态布局#\n\n\n\n 1. 基本结构\n    \n    \n\n 2. 按需导入组件\n    \n    \n\n\n39. 购物车 - 构建 vuex 模块 - 获取数据存储#\n\n\n\n 1. 新建 modules/cart.js 模块\n    \n    \n\n 2. 挂载到 store 上面\n    \n    \n\n 3. 封装 API 接口 api/cart.js\n    \n    \n\n 4. 封装 action 和 mutation\n    \n    \n\n 5. 页面中 dispatch 调用\n    \n    \n\n\n40. 购物车 - mapState - 渲染购物车列表#\n\n 1. 将数据映射到页面\n    \n    \n\n 2. 动态渲染\n    \n    \n\n\n41. 购物车 - 封装 getters - 动态计算展示#\n\n 1. 封装 getters：商品总数 / 选中的商品列表 / 选中的商品总数 / 选中的商品总价\n    \n    \n\n 2. 页面中 mapGetters 映射使用\n    \n    \n\n\n42. 购物车 - 全选反选功能#\n\n 1. 全选 getters\n    \n    \n\n 2. 点击小选，修改状态\n    \n    \n\n 3. 点击全选，重置状态\n    \n    \n\n\n43. 购物车 - 数字框修改数量#\n\n 1. 封装 api 接口\n    \n    \n\n 2. 页面中注册点击事件，传递数据\n    \n    \n\n 3. 提供 action 发送请求， commit mutation\n    \n    \n\n\n44. 购物车 - 编辑切换状态#\n\n 1. data 提供数据, 定义是否在编辑删除的状态\n    \n    \n\n 2. 注册点击事件，修改状态\n    \n    \n\n 3. 底下按钮根据状态变化\n    \n    \n\n 4. 监视编辑状态，动态控制复选框状态\n    \n    \n\n\n45. 购物车 - 删除功能完成#\n\n 1. 查看接口，封装 API ( 注意：此处 id 为获取回来的购物车数据的 id )\n    \n    \n\n 2. 注册删除点击事件\n    \n    \n\n 3. 提供 actions\n    \n    \n\n\n46. 购物车 - 空购物车处理#\n\n 1. 外面包个大盒子，添加 v-if 判断\n    \n    \n\n 2. 相关样式\n    \n    \n\n\n47. 订单结算台#\n\n所谓的 “立即结算”，本质就是跳转到订单结算台，并且跳转的同时，需要携带上对应的订单参数。\n\n而具体需要哪些参数，就需要基于 【订单结算台】 的需求来定。\n\n\n(1) 静态布局#\n\n\n\n * 准备静态页面\n   \n   \n\n\n(2) 获取收货地址列表#\n\n 1. 封装获取地址的接口\n    \n    \n\n 2. 页面中 - 调用获取地址\n    \n    \n\n 3. 页面中 - 进行渲染\n    \n    \n\n\n(3) 订单结算 - 封装通用接口#\n\n**思路分析：**这里的订单结算，有两种情况：\n\n 1. 购物车结算，需要两个参数\n    \n    ① mode=\"cart\"\n    \n    ② cartIds=\"cartId, cartId\"\n\n 2. 立即购买结算，需要三个参数\n    \n    ① mode=\"buyNow\"\n    \n    ② goodsId=\"商品id\"\n    \n    ③ goodsSkuId=\"商品skuId\"\n\n都需要跳转时将参数传递过来\n\n--------------------------------------------------------------------------------\n\n封装通用 API 接口 api/order\n\n\n\n\n(4) 订单结算 - 购物车结算#\n\n 1. 跳转时，传递查询参数\n    \n    layout/cart.vue\n    \n    \n\n 2. 页面中接收参数, 调用接口，获取数据\n    \n    \n\n 3. 基于数据进行渲染\n    \n    \n\n\n(5) 订单结算 - 立即购买结算#\n\n 1. 点击跳转传参\n    \n    prodetail/index.vue\n    \n    \n\n 2. 计算属性处理参数\n    \n    \n\n 3. 基于请求时携带参数发请求渲染\n    \n    \n\n\n(6) mixins 复用 - 处理登录确认框的弹出#\n\n 1. 新建一个 mixin 文件 mixins/loginConfirm.js\n    \n    \n\n 2. 页面中导入，混入方法\n    \n    \n\n 3. 页面中调用 混入的方法\n    \n    \n\n\n48. 提交订单并支付#\n\n 1. 封装 API 通用方法（统一余额支付）\n    \n    \n\n 2. 买家留言绑定\n    \n    \n\n 3. 注册点击事件，提交订单并支付\n    \n    \n\n\n49. 订单管理#\n\n\n(1) 静态布局#\n\n 1. 基础静态结构\n    \n    \n\n 2. components/OrderListItem\n    \n    \n\n 3. 导入注册\n    \n    \n\n\n(2) 点击 tab 切换渲染#\n\n 1. 封装获取订单列表的 API 接口\n    \n    \n\n 2. 给 tab 绑定 name 属性\n    \n    \n\n 3. 封装调用接口获取数据\n    \n    \n\n 4. 动态渲染\n    \n    \n\n\n50. 个人中心 - 基本渲染#\n\n 1. 封装获取个人信息 - API接口\n    \n    \n\n 2. 调用接口，获取数据进行渲染\n    \n    \n\n\n51. 个人中心 - 退出功能#\n\n 1. 注册点击事件\n    \n    \n\n 2. 提供方法\n    \n    \n\n\n52. 项目打包优化#\n\nvue脚手架只是开发过程中，协助开发的工具，当真正开发完了 => 脚手架不参与上线\n\n参与上线的是 => 打包后的源代码\n\n打包：\n\n * 将多个文件压缩合并成一个文件\n * 语法降级\n * less sass ts 语法解析, 解析成css\n * ....\n\n打包后，可以生成，浏览器能够直接运行的网页 => 就是需要上线的源码！\n\n\n(1) 打包命令#\n\nvue脚手架工具已经提供了打包命令，直接使用即可。\n\n\n\n在项目的根目录会自动创建一个文件夹dist,dist中的文件就是打包后的文件，只需要放到服务器中即可。\n\n\n(2) 配置publicPath#\n\n\n\n\n(3) 路由懒加载#\n\n路由懒加载 & 异步组件， 不会一上来就将所有的组件都加载，而是访问到对应的路由了，才加载解析这个路由对应的所有组件\n\n官网链接：https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E4%BD%BF%E7%9\n4%A8-webpack\n\n> 当打包构建应用时，JavaScript\n> 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n\n","routePath":"/vue/day08-day10-智慧商城项目/智慧商城项目","lang":"","toc":[{"text":"01. 项目功能演示","id":"01-项目功能演示","depth":2,"charIndex":135},{"text":"1.明确功能模块","id":"1明确功能模块","depth":3,"charIndex":149},{"text":"2.项目收获","id":"2项目收获","depth":3,"charIndex":190},{"text":"02. 项目创建目录初始化","id":"02-项目创建目录初始化","depth":2,"charIndex":202},{"text":"vue-cli 建项目","id":"vue-cli-建项目","depth":3,"charIndex":219},{"text":"03. 调整初始化目录结构","id":"03-调整初始化目录结构","depth":2,"charIndex":547},{"text":"1.删除文件","id":"1删除文件","depth":3,"charIndex":679},{"text":"2.修改文件","id":"2修改文件","depth":3,"charIndex":801},{"text":"3.新增目录","id":"3新增目录","depth":3,"charIndex":867},{"text":"04. vant组件库及Vue周边的其他组件库","id":"04-vant组件库及vue周边的其他组件库","depth":2,"charIndex":971},{"text":"05. 全部导入和按需导入的区别","id":"05-全部导入和按需导入的区别","depth":2,"charIndex":1224},{"text":"06. 全部导入","id":"06-全部导入","depth":2,"charIndex":1335},{"text":"07. 按需导入","id":"07-按需导入","depth":2,"charIndex":1427},{"text":"08. 项目中的vw适配","id":"08-项目中的vw适配","depth":2,"charIndex":1594},{"text":"09. 路由配置 - 一级路由","id":"09-路由配置---一级路由","depth":2,"charIndex":1873},{"text":"10. 路由配置-tabbar标签页","id":"10-路由配置-tabbar标签页","depth":2,"charIndex":2070},{"text":"11. 路由配置 - 二级路由","id":"11-路由配置---二级路由","depth":2,"charIndex":2221},{"text":"12. 登录页静态布局","id":"12-登录页静态布局","depth":2,"charIndex":2433},{"text":"(1) 准备工作","id":"1-准备工作","depth":3,"charIndex":2448},{"text":"(2) 登录静态布局","id":"2-登录静态布局","depth":3,"charIndex":2571},{"text":"13. request模块 - axios封装","id":"13-request模块---axios封装","depth":2,"charIndex":2685},{"text":"14. 图形验证码功能完成","id":"14-图形验证码功能完成","depth":2,"charIndex":3245},{"text":"15. 封装api接口 - 图片验证码接口","id":"15-封装api接口---图片验证码接口","depth":2,"charIndex":3347},{"text":"16. toast 轻提示","id":"16-toast-轻提示","depth":2,"charIndex":3593},{"text":"17. 短信验证倒计时功能","id":"17-短信验证倒计时功能","depth":2,"charIndex":3776},{"text":"(1) 倒计时基础效果","id":"1-倒计时基础效果","depth":3,"charIndex":3795},{"text":"(2) 验证码请求校验处理","id":"2-验证码请求校验处理","depth":3,"charIndex":3908},{"text":"(3) 封装接口，请求获取验证码","id":"3-封装接口请求获取验证码","depth":3,"charIndex":4013},{"text":"18. 封装api接口 - 登录功能","id":"18-封装api接口---登录功能","depth":2,"charIndex":4091},{"text":"19. 响应拦截器统一处理错误提示","id":"19-响应拦截器统一处理错误提示","depth":2,"charIndex":4165},{"text":"20. 将登录权证信息存入 vuex","id":"20-将登录权证信息存入-vuex","depth":2,"charIndex":4265},{"text":"21. vuex持久化处理","id":"21-vuex持久化处理","depth":2,"charIndex":4423},{"text":"22. 优化：添加请求 loading 效果","id":"22-优化添加请求-loading-效果","depth":2,"charIndex":4513},{"text":"23. 登录访问拦截 - 路由前置守卫","id":"23-登录访问拦截---路由前置守卫","depth":2,"charIndex":4599},{"text":"24. 首页 - 静态结构准备","id":"24-首页---静态结构准备","depth":2,"charIndex":4831},{"text":"25. 首页 - 动态渲染","id":"25-首页---动态渲染","depth":2,"charIndex":4955},{"text":"26. 搜索 - 静态布局准备","id":"26-搜索---静态布局准备","depth":2,"charIndex":5084},{"text":"27. 搜索 - 历史记录 - 基本管理","id":"27-搜索---历史记录---基本管理","depth":2,"charIndex":5150},{"text":"28. 搜索 - 历史记录 - 持久化","id":"28-搜索---历史记录---持久化","depth":2,"charIndex":5331},{"text":"29. 搜索列表 - 静态布局","id":"29-搜索列表---静态布局","depth":2,"charIndex":5412},{"text":"30. 搜索列表 - 动态渲染","id":"30-搜索列表---动态渲染","depth":2,"charIndex":5435},{"text":"(1) 搜索关键字搜索","id":"1-搜索关键字搜索","depth":3,"charIndex":5454},{"text":"(2) 分类id搜索","id":"2-分类id搜索","depth":3,"charIndex":5618},{"text":"31. 商品详情 - 静态布局","id":"31-商品详情---静态布局","depth":2,"charIndex":5721},{"text":"32. 商品详情 - 动态渲染介绍","id":"32-商品详情---动态渲染介绍","depth":2,"charIndex":5788},{"text":"33. 商品详情 - 动态渲染评价","id":"33-商品详情---动态渲染评价","depth":2,"charIndex":5933},{"text":"34. 加入购物车 - 唤起弹窗","id":"34-加入购物车---唤起弹窗","depth":2,"charIndex":6035},{"text":"35. 加入购物车 - 封装数字框组件","id":"35-加入购物车---封装数字框组件","depth":2,"charIndex":6214},{"text":"36. 加入购物车 - 判断 token 登录提示","id":"36-加入购物车---判断-token-登录提示","depth":2,"charIndex":6303},{"text":"37. 加入购物车 - 封装接口进行请求","id":"37-加入购物车---封装接口进行请求","depth":2,"charIndex":6554},{"text":"38. 购物车 - 静态布局","id":"38-购物车---静态布局","depth":2,"charIndex":6719},{"text":"39. 购物车 - 构建 vuex 模块 - 获取数据存储","id":"39-购物车---构建-vuex-模块---获取数据存储","depth":2,"charIndex":6781},{"text":"40. 购物车 - mapState - 渲染购物车列表","id":"40-购物车---mapstate---渲染购物车列表","depth":2,"charIndex":6985},{"text":"41. 购物车 - 封装 getters - 动态计算展示","id":"41-购物车---封装-getters---动态计算展示","depth":2,"charIndex":7061},{"text":"42. 购物车 - 全选反选功能","id":"42-购物车---全选反选功能","depth":2,"charIndex":7190},{"text":"43. 购物车 - 数字框修改数量","id":"43-购物车---数字框修改数量","depth":2,"charIndex":7286},{"text":"44. 购物车 - 编辑切换状态","id":"44-购物车---编辑切换状态","depth":2,"charIndex":7409},{"text":"45. 购物车 - 删除功能完成","id":"45-购物车---删除功能完成","depth":2,"charIndex":7553},{"text":"46. 购物车 - 空购物车处理","id":"46-购物车---空购物车处理","depth":2,"charIndex":7679},{"text":"47. 订单结算台","id":"47-订单结算台","depth":2,"charIndex":7753},{"text":"(1) 静态布局","id":"1-静态布局","depth":3,"charIndex":7845},{"text":"(2) 获取收货地址列表","id":"2-获取收货地址列表","depth":3,"charIndex":7878},{"text":"(3) 订单结算 - 封装通用接口","id":"3-订单结算---封装通用接口","depth":3,"charIndex":7973},{"text":"(4) 订单结算 - 购物车结算","id":"4-订单结算---购物车结算","depth":3,"charIndex":8320},{"text":"(5) 订单结算 - 立即购买结算","id":"5-订单结算---立即购买结算","depth":3,"charIndex":8449},{"text":"(6) mixins 复用 - 处理登录确认框的弹出","id":"6-mixins-复用---处理登录确认框的弹出","depth":3,"charIndex":8575},{"text":"48. 提交订单并支付","id":"48-提交订单并支付","depth":2,"charIndex":8710},{"text":"49. 订单管理","id":"49-订单管理","depth":2,"charIndex":8812},{"text":"(1) 静态布局","id":"1-静态布局-1","depth":3,"charIndex":8824},{"text":"(2) 点击 tab 切换渲染","id":"2-点击-tab-切换渲染","depth":3,"charIndex":8918},{"text":"50. 个人中心 - 基本渲染","id":"50-个人中心---基本渲染","depth":2,"charIndex":9047},{"text":"51. 个人中心 - 退出功能","id":"51-个人中心---退出功能","depth":2,"charIndex":9127},{"text":"52. 项目打包优化","id":"52-项目打包优化","depth":2,"charIndex":9188},{"text":"(1) 打包命令","id":"1-打包命令","depth":3,"charIndex":9370},{"text":"(2) 配置publicPath","id":"2-配置publicpath","depth":3,"charIndex":9464},{"text":"(3) 路由懒加载","id":"3-路由懒加载","depth":3,"charIndex":9486}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"认识Vue3","content":"#\n\n\n1. Vue2 选项式 API vs Vue3 组合式API#\n\n\n\n\n\n特点：\n\n 1. 代码量变少\n\n 2. 分散式维护变成集中式维护\n\n\n2. Vue3的优势#\n\n\n\n\n使用create-vue搭建Vue3项目#\n\n\n1. 认识create-vue#\n\n> create-vue是Vue官方新的脚手架工具，底层切换到了 vite （下一代前端工具链），为开发提供极速响应\n\n\n\n\n2. 使用create-vue创建项目#\n\n> 前置条件 - 已安装16.0或更高版本的Node.js\n\n执行如下命令，这一指令将会安装并执行 create-vue\n\n\n\n\n\n\n熟悉项目和关键文件#\n\n\n\n\n组合式API - setup选项#\n\n\n1. setup选项的写法和执行时机#\n\n写法\n\n\n\n执行时机\n\n> 在beforeCreate钩子之前执行\n\n\n\n\n2. setup中写代码的特点#\n\n> 在setup函数中写的数据和方法需要在末尾以对象的方式return，才能给模版使用\n\n\n\n\n3.\n\n\n组合式API - reactive和ref函数#\n\n\n1. reactive#\n\n> 接受对象类型数据的参数传入并返回一个响应式的对象\n\n\n\n\n2. ref#\n\n> 接收简单类型或者对象类型的数据传入并返回一个响应式的对象\n\n\n\n\n3. reactive 对比 ref#\n\n 1. 都是用来生成响应式数据\n 2. 不同点\n    1. reactive不能处理简单类型的数据\n    2. ref参数类型支持更好，但是必须通过.value做访问修改\n    3. ref函数内部的实现依赖于reactive函数\n 3. 在实际工作中的推荐\n    1. 推荐使用ref函数，减少记忆负担，小兔鲜项目都使用ref\n\n\n组合式API - computed#\n\n> 计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法\n\n\n\n\n组合式API - watch#\n\n> 侦听一个或者多个数据的变化，数据变化时执行回调函数，俩个额外参数 immediate控制立刻执行，deep开启深度侦听\n\n\n1. 侦听单个数据#\n\n\n\n\n2. 侦听多个数据#\n\n> 侦听多个数据，第一个参数可以改写成数组的写法\n\n\n\n\n3. immediate#\n\n> 在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调\n\n\n\n\n4. deep#\n\n> 通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep\n\n\n\n\n组合式API - 生命周期函数#\n\n\n1. 选项式对比组合式#\n\n\n\n\n2. 生命周期函数基本使用#\n\n>  1. 导入生命周期函数\n>  2. 执行生命周期函数，传入回调\n\n\n\n\n3. 执行多次#\n\n> 生命周期函数执行多次的时候，会按照顺序依次执行\n\n\n\n\n组合式API - 父子通信#\n\n\n1. 父传子#\n\n> 基本思想 1.父组件中给子组件绑定属性 2.子组件内部通过props选项接收数据\n\n\n\n\n2. 子传父#\n\n> 基本思想 1.父组件中给子组件标签通过@绑定事件 2.子组件内部通过 emit 方法触发事件\n\n\n\n\n组合式API - 模版引用#\n\n> 概念：通过 ref标识 获取真实的 dom对象或者组件实例对象\n\n\n1. 基本使用#\n\n> 实现步骤： 1.调用ref函数生成一个ref对象 2.通过ref标识绑定ref对象到标签\n\n\n\n\n2. defineExpose#\n\n> 默认情况下在","routePath":"/vue/day11-Vue3入门/Vue3入门","lang":"","toc":[{"text":"1. Vue2 选项式 API vs Vue3 组合式API","id":"1-vue2-选项式-api-vs-vue3-组合式api","depth":2,"charIndex":3},{"text":"2. Vue3的优势","id":"2-vue3的优势","depth":2,"charIndex":75},{"text":"使用create-vue搭建Vue3项目","id":"使用create-vue搭建vue3项目","depth":2,"charIndex":91},{"text":"1. 认识create-vue","id":"1-认识create-vue","depth":2,"charIndex":115},{"text":"2. 使用create-vue创建项目","id":"2-使用create-vue创建项目","depth":2,"charIndex":196},{"text":"熟悉项目和关键文件","id":"熟悉项目和关键文件","depth":2,"charIndex":285},{"text":"组合式API - setup选项","id":"组合式api---setup选项","depth":2,"charIndex":300},{"text":"1. setup选项的写法和执行时机","id":"1-setup选项的写法和执行时机","depth":2,"charIndex":320},{"text":"2. setup中写代码的特点","id":"2-setup中写代码的特点","depth":2,"charIndex":379},{"text":"3. `<script setup>`语法糖","id":"3-script-setup语法糖","depth":2,"charIndex":-1},{"text":"组合式API - reactive和ref函数","id":"组合式api---reactive和ref函数","depth":2,"charIndex":450},{"text":"1. reactive","id":"1-reactive","depth":2,"charIndex":477},{"text":"2. ref","id":"2-ref","depth":2,"charIndex":522},{"text":"3. reactive 对比 ref","id":"3-reactive-对比-ref","depth":2,"charIndex":566},{"text":"组合式API - computed","id":"组合式api---computed","depth":2,"charIndex":758},{"text":"组合式API - watch","id":"组合式api---watch","depth":2,"charIndex":825},{"text":"1. 侦听单个数据","id":"1-侦听单个数据","depth":2,"charIndex":906},{"text":"2. 侦听多个数据","id":"2-侦听多个数据","depth":2,"charIndex":921},{"text":"3. immediate","id":"3-immediate","depth":2,"charIndex":962},{"text":"4. deep","id":"4-deep","depth":2,"charIndex":1013},{"text":"组合式API - 生命周期函数","id":"组合式api---生命周期函数","depth":2,"charIndex":1082},{"text":"1. 选项式对比组合式","id":"1-选项式对比组合式","depth":2,"charIndex":1101},{"text":"2. 生命周期函数基本使用","id":"2-生命周期函数基本使用","depth":2,"charIndex":1118},{"text":"3. 执行多次","id":"3-执行多次","depth":2,"charIndex":1173},{"text":"组合式API - 父子通信","id":"组合式api---父子通信","depth":2,"charIndex":1213},{"text":"1. 父传子","id":"1-父传子","depth":2,"charIndex":1230},{"text":"2. 子传父","id":"2-子传父","depth":2,"charIndex":1286},{"text":"组合式API - 模版引用","id":"组合式api---模版引用","depth":2,"charIndex":1348},{"text":"1. 基本使用","id":"1-基本使用","depth":2,"charIndex":1400},{"text":"2. defineExpose","id":"2-defineexpose","depth":2,"charIndex":1461},{"text":"组合式API - provide和inject","id":"组合式api---provide和inject","depth":2,"charIndex":-1},{"text":"1. 作用和场景","id":"1-作用和场景","depth":2,"charIndex":-1},{"text":"2. 跨层传递普通数据","id":"2-跨层传递普通数据","depth":2,"charIndex":-1},{"text":"3. 跨层传递响应式数据","id":"3-跨层传递响应式数据","depth":2,"charIndex":-1},{"text":"4. 跨层传递方法","id":"4-跨层传递方法","depth":2,"charIndex":-1},{"text":"Vue3.3新特性-defineOptions","id":"vue33新特性-defineoptions","depth":2,"charIndex":-1},{"text":"Vue3.3新特性-defineModel","id":"vue33新特性-definemodel","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"Vue3 状态管理 - Pinia","content":"#\n\n\n1. 什么是Pinia#\n\nPinia 是 Vue 的专属的最新状态管理库 ，是 Vuex 状态管理工具的替代品\n\n\n2. 手动添加Pinia到Vue项目#\n\n后面在实际开发项目的时候，Pinia可以在项目创建时自动添加，现在我们初次学习，从零开始：\n\n 1. 使用 Vite 创建一个空的 Vue3项目\n    \n    \n\n 2. 按照官方文档安装 pinia 到项目中\n\n\n3. Pinia基础使用#\n\n 1. 定义store\n 2. 组件使用store\n\n\n\n\n4. getters实现#\n\nPinia中的 getters 直接使用 computed函数 进行模拟, 组件中需要使用需要把 getters return出去\n\n\n\n\n5. action异步实现#\n\n方式：异步action函数的写法和组件中获取异步数据的写法完全一致\n\n * 接口地址：http://geek.itheima.net/v1_0/channels\n\n * 请求方式：get\n\n * 请求参数：无\n\n\n\n需求：在Pinia中获取频道列表数据并把数据渲染App组件的模板中\n\n\n6. storeToRefs工具函数#\n\n使用storeToRefs函数可以辅助保持数据（state - getter）的响应式解构\n\n\n7. Pinia的调试#\n\nVue官方的 dev-tools 调试工具 对 Pinia直接支持，可以直接进行调试\n\n\n8. Pinia持久化插件#\n\n官方文档：https://prazdevs.github.io/pinia-plugin-persistedstate/zh/\n\n 1. 安装插件 pinia-plugin-persistedstate\n\n\n\n 2. 使用 main.js\n\n\n\n 3. 配置 store/counter.js\n\n\n\n 4. 其他配置，看官网文档即可","routePath":"/vue/day12-Pinia/Pinia","lang":"","toc":[{"text":"1. 什么是Pinia","id":"1-什么是pinia","depth":2,"charIndex":3},{"text":"2. 手动添加Pinia到Vue项目","id":"2-手动添加pinia到vue项目","depth":2,"charIndex":62},{"text":"3. Pinia基础使用","id":"3-pinia基础使用","depth":2,"charIndex":193},{"text":"4. getters实现","id":"4-getters实现","depth":2,"charIndex":238},{"text":"5. action异步实现","id":"5-action异步实现","depth":2,"charIndex":323},{"text":"6. storeToRefs工具函数","id":"6-storetorefs工具函数","depth":2,"charIndex":483},{"text":"7. Pinia的调试","id":"7-pinia的调试","depth":2,"charIndex":552},{"text":"8. Pinia持久化插件","id":"8-pinia持久化插件","depth":2,"charIndex":611}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"后台数据管理系统 - 项目架构设计","content":"#\n\n在线演示：https://fe-bigevent-web.itheima.net/login\n\n接口文档:\nhttps://apifox.com/apidoc/shared-26c67aee-0233-4d23-aab7-08448fdf95ff/api-938508\n35\n\n接口根路径： http://big-event-vue-api-t.itheima.net\n\n本项目的技术栈 本项目技术栈基于 ES6、vue3、pinia、vue-router 、vite 、axios 和 element-plus\n\n\n\n\n项目页面介绍#\n\n\n\n\n\n\n\n\n\n\npnpm 包管理器 - 创建项目#\n\n一些优势：比同类工具快 2倍 左右、节省磁盘空间... https://www.pnpm.cn/\n\n安装方式：\n\n\n\n创建项目：\n\n\n\n\n\n\nESLint & prettier 配置代码风格#\n\n环境同步：\n\n 1. 安装了插件 ESlint，开启保存自动修复\n 2. 禁用了插件 Prettier，并关闭保存自动格式化\n\n\n\n配置文件 .eslintrc.cjs\n\n 1. prettier 风格配置 https://prettier.io\n    \n    1. 单引号\n    \n    2. 不使用分号\n    \n    3. 每行宽度至多80字符\n    \n    4. 不加对象|数组最后逗号\n    \n    5. 换行符号不限制（win mac 不一致）\n\n 2. vue组件名称多单词组成（忽略index.vue）\n\n 3. props解构（关闭）\n\n\n\n\n基于 husky 的代码检查工作流#\n\nhusky 是一个 git hooks 工具 ( git的钩子工具，可以在特定时机执行特定的命令 )\n\nhusky 配置\n\n 1. git初始化 git init\n\n 2. 初始化 husky 工具配置 https://typicode.github.io/husky/\n    \n    \n\n 3. 修改 .husky/pre-commit 文件\n    \n    \n\n**问题：**默认进行的是全量检查，耗时问题，历史问题。\n\nlint-staged 配置\n\n 1. 安装\n    \n    \n\n 2. 配置 package.json\n    \n    \n\n 3. 修改 .husky/pre-commit 文件\n    \n    \n\n\n调整项目目录#\n\n默认生成的目录结构不满足我们的开发需求，所以这里需要做一些自定义改动。主要是两个工作：\n\n * 删除初始化的默认文件\n * 修改剩余代码内容\n * 新增调整我们需要的目录结构\n * 拷贝初始化资源文件，安装预处理器插件\n\n 1. 删除文件\n\n 2. 修改内容\n    \n    src/router/index.js\n    \n    \n    \n    src/App.vue\n    \n    \n    \n    src/main.js\n    \n    \n\n 3. 新增需要目录 api utils\n    \n    \n\n 4. 将项目需要的全局样式 和 图片文件，复制到 ./assets 文件夹中, 并将全局样式在main.js中引入\n    \n    \n    \n    * 安装 sass 依赖\n    \n    \n\n\nVueRouter4 路由代码解析#\n\n基础代码解析\n\n\n\nimport.meta.env.BASE_URL 是Vite\n环境变量：https://cn.vitejs.dev/guide/env-and-mode.html\n\n\n引入 element-ui 组件库#\n\n官方文档： https://element-plus.org/zh-CN/\n\n * 安装\n\n\n\n自动按需：\n\n 1. 安装插件\n    \n    \n\n 2. 然后把下列代码插入到你的 Vite 或 Webpack 的配置文件中\n    \n    \n\n 3. 直接使用\n    \n    \n    \n    \n\n**彩蛋：**默认 components 下的文件也会被自动注册~\n\n\nPinia - 构建用户仓库 和 持久化#\n\n官方文档：https://prazdevs.github.io/pinia-plugin-persistedstate/zh/\n\n 1. 安装插件 pinia-plugin-persistedstate\n    \n    \n\n 2. 使用 main.js\n    \n    \n\n 3. 配置 stores/user.js\n    \n    \n\n\nPinia - 配置仓库统一管理#\n\npinia 独立维护\n\n- 现在：初始化代码在 main.js 中，仓库代码在 stores 中，代码分散职能不单一\n\n- 优化：由 stores 统一维护，在 stores/index.js 中完成 pinia 初始化，交付 main.js 使用\n\n仓库 统一导出\n\n- 现在：使用一个仓库 import { useUserStore } from ./stores/user.js 不同仓库路径不一致\n\n- 优化：由 stores/index.js 统一导出，导入路径统一 ./stores，而且仓库维护在 stores/modules 中\n\n\n数据交互 - 请求工具设计#\n\n\n\n\n1. 创建 axios 实例#\n\n们会使用 axios 来请求后端接口, 一般都会对 axios 进行一些配置 (比如: 配置基础地址等)\n\n一般项目开发中, 都会对 axios 进行基本的二次封装, 单独封装到一个模块中, 便于使用\n\n 1. 安装 axios\n    \n    \n\n 2. 新建 utils/request.js 封装 axios 模块\n    \n    利用 axios.create 创建一个自定义的 axios 来使用\n    \n    http://www.axios-js.com/zh-cn/docs/#axios-create-config\n    \n    \n\n\n2. 完成 axios 基本配置#\n\n\n\n\n首页整体路由设计#\n\n实现目标:\n\n * 完成整体路由规划【搞清楚要做几个页面，它们分别在哪个路由下面，怎么跳转的.....】\n * 通过观察, 点击左侧导航, 右侧区域在切换, 那右侧区域内容一直在变, 那这个地方就是一个路由的出口\n * 我们需要搭建嵌套路由\n\n目标：\n\n * 把项目中所有用到的组件及路由表, 约定下来\n\n约定路由规则\n\nPATH                  文件                                 功能      组件名               路由级别\n/login                views/login/LoginPage.vue          登录&注册   LoginPage         一级路由\n/                     views/layout/LayoutContainer.vue   布局架子    LayoutContainer   一级路由\n├─ /article/manage    views/article/ArticleManage.vue    文章管理    ArticleManage     二级路由\n├─ /article/channel   views/article/ArticleChannel.vue   频道管理    ArticleChannel    二级路由\n├─ /user/profile      views/user/UserProfile.vue         个人详情    UserProfile       二级路由\n├─ /user/avatar       views/user/UserAvatar.vue          更换头像    UserAvatar        二级路由\n├─ /user/password     views/user/UserPassword.vue        重置密码    UserPassword      二级路由\n\n明确了路由规则，可以全部配完，也可以边写边配。\n\n\n登录注册页面 [element-plus 表单 & 表单校验]#\n\n\n注册登录 静态结构 & 基本切换#\n\n 1. 安装 element-plus 图标库\n    \n    \n\n 2. 静态结构准备\n    \n    \n\n\n注册功能#\n\n\n实现注册校验#\n\n【需求】注册页面基本校验\n\n 1. 用户名非空，长度校验5-10位\n 2. 密码非空，长度校验6-15位\n 3. 再次输入密码，非空，长度校验6-15位\n\n【进阶】再次输入密码需要自定义校验规则，和密码框值一致（可选）\n\n注意：\n\n 1. model 属性绑定 form 数据对象\n    \n    \n\n 2. v-model 绑定 form 数据对象的子属性\n    \n    \n\n 3. rules 配置校验规则\n    \n    \n\n 4. prop 绑定校验规则\n    \n    \n\n\n注册前的预校验#\n\n需求：点击注册按钮，注册之前，需要先校验\n\n 1. 通过 ref 获取到 表单组件\n    \n    \n\n 2. 注册之前进行校验\n    \n    \n\n\n封装 api 实现注册功能#\n\n需求：封装注册api，进行注册，注册成功切换到登录\n\n 1. 新建 api/user.js 封装\n    \n    \n\n 2. 页面中调用\n    \n    \n\n 3. eslintrc 中声明全局变量名, 解决 ElMessage 报错问题\n    \n    \n\n\n登录功能#\n\n\n实现登录校验#\n\n【需求说明】给输入框添加表单校验\n\n 1. 用户名不能为空，用户名必须是5-10位的字符，失去焦点 和 修改内容时触发校验\n 2. 密码不能为空，密码必须是6-15位的字符，失去焦点 和 修改内容时触发校验\n\n操作步骤：\n\n 1. model 属性绑定 form 数据对象，直接绑定之前提供好的数据对象即可\n    \n    \n\n 2. rules 配置校验规则，共用注册的规则即可\n    \n    \n\n 3. v-model 绑定 form 数据对象的子属性\n    \n    \n\n 4. prop 绑定校验规则\n    \n    \n\n 5. 切换的时候重置\n    \n    \n\n\n登录前的预校验 & 登录成功#\n\n【需求说明1】登录之前的预校验\n\n * 登录请求之前，需要对用户的输入内容，进行校验\n * 校验通过才发送请求\n\n【需求说明2】登录功能\n\n 1. 封装登录API，点击按钮发送登录请求\n 2. 登录成功存储token，存入pinia 和 持久化本地storage\n 3. 跳转到首页，给提示\n\n【测试账号】\n\n * 登录的测试账号: shuaipeng\n\n * 登录测试密码: 123456\n\nPS: 每天账号会重置，如果被重置了，可以去注册页，注册一个新号\n\n实现步骤：\n\n 1. 注册事件，进行登录前的预校验 (获取到组件调用方法)\n    \n    \n\n 2. 封装接口 API\n    \n    \n\n 3. 调用方法将 token 存入 pinia 并 自动持久化本地\n    \n    \n\n\n首页 layout 架子 [element-plus 菜单]#\n\n\n基本架子拆解#\n\n架子组件列表：\n\nel-container\n\n * el-aside 左侧\n   \n   * el-menu 左侧边栏菜单\n\n * el-container 右侧\n   \n   * el-header 右侧头部\n     * el-dropdown\n   * el-main 右侧主体\n     * router-view\n\n\n\n\n登录访问拦截#\n\n需求：只有登录页，可以未授权的时候访问，其他所有页面，都需要先登录再访问\n\n\n\n\n用户基本信息获取&渲染#\n\n 1. api/user.js封装接口\n    \n    \n\n 2. stores/modules/user.js 定义数据\n    \n    \n\n 3. layout/LayoutContainer页面中调用\n    \n    \n\n 4. 动态渲染\n    \n    \n\n\n退出功能 [element-plus 确认框]#\n\n 1. 注册点击事件\n    \n    \n\n 2. 添加退出功能\n    \n    \n\n 3. pinia user.js 模块 提供 setUser 方法\n    \n    \n\n\n文章分类页面 - [element-plus 表格]#\n\n\n基本架子 - PageContainer#\n\n 1. 基本结构样式，用到了 el-card 组件\n    \n    \n\n 2. 考虑到多个页面复用，封装成组件\n    \n    * props 定制标题\n    * 默认插槽 default 定制内容主体\n    * 具名插槽 extra 定制头部右侧额外的按钮\n    \n    \n\n 3. 页面中直接使用测试 ( unplugin-vue-components 会自动注册)\n\n * 文章分类测试：\n   \n   \n\n * 文章管理测试：\n   \n   \n\n\n文章分类渲染#\n\n\n封装API - 请求获取表格数据#\n\n 1. 新建 api/article.js 封装获取频道列表的接口\n    \n    \n\n 2. 页面中调用接口，获取数据存储\n    \n    \n\n\nel-table 表格动态渲染#\n\n\n\n\nel-table 表格 loading 效果#\n\n 1. 定义变量，v-loading绑定\n    \n    \n\n 2. 发送请求前开启，请求结束关闭\n    \n    \n\n\n文章分类添加编辑 [element-plus 弹层]#\n\n\n点击显示弹层#\n\n 1. 准备弹层\n    \n    \n\n 2. 点击事件\n    \n    \n\n\n封装弹层组件 ChannelEdit#\n\n添加 和 编辑，可以共用一个弹层，所以可以将弹层封装成一个组件\n\n组件对外暴露一个方法 open, 基于 open 的参数，初始化表单数据，并判断区分是添加 还是 编辑\n\n 1. open({ }) => 添加操作，添加表单初始化无数据\n 2. open({ id: xx, ... }) => 编辑操作，编辑表单初始化需回显\n\n具体实现：\n\n 1. 封装组件 article/components/ChannelEdit.vue\n    \n    \n\n 2. 通过 ref 绑定\n    \n    \n\n 3. 点击调用方法显示弹窗\n    \n    \n\n\n准备弹层表单#\n\n 1. 准备数据 和 校验规则\n    \n    \n\n 2. 准备表单\n    \n    \n\n 3. 编辑需要回显，表单数据需要初始化\n    \n    \n\n 4. 基于传过来的表单数据，进行标题控制，有 id 的是编辑\n    \n    \n\n\n确认提交#\n\n 1. api/article.js 封装请求 API\n    \n    \n\n 2. 页面中校验，判断，提交请求\n    \n    \n    \n    \n\n 3. 通知父组件进行回显\n    \n    \n\n 4. 父组件监听 success 事件，进行调用回显\n    \n    \n\n\n文章分类删除#\n\n 1. api/article.js封装接口 api\n    \n    \n\n 2. 页面中添加确认框，调用接口进行提示\n    \n    \n\n\n文章管理页面 - [element-plus 强化]#\n\n\n文章列表渲染#\n\n\n基本架子搭建#\n\n\n\n 1. 搜索表单\n    \n    \n\n 2. 表格准备，模拟假数据渲染\n    \n    \n    \n    \n\n\n中英国际化处理#\n\n默认是英文的，由于这里不涉及切换， 所以在 App.vue 中直接导入设置成中文即可，\n\n\n\n\n文章分类选择#\n\n为了便于维护，直接拆分成一个小组件 ChannelSelect.vue\n\n 1. 新建 article/components/ChannelSelect.vue\n    \n    \n\n 2. 页面中导入渲染\n    \n    \n\n 3. 调用接口，动态渲染下拉分类，设计成 v-model 的使用方式\n    \n    \n\n 4. 父组件定义参数绑定\n    \n    \n\n 5. 发布状态，也绑定一下，便于将来提交表单\n    \n    \n\n\n封装 API 接口，请求渲染#\n\n没有数据，可以登录已完成的系统，添加几条数据\n\n 1. api/article.js封装接口\n    \n    \n\n 2. 页面中调用保存数据\n    \n    \n\n 3. 新建 utils/format.js 封装格式化日期函数\n    \n    \n\n 4. 导入使用\n    \n    \n\n\n分页渲染 [element-plus 分页]#\n\n 1. 分页组件\n    \n    \n\n 2. 提供分页修改逻辑\n    \n    \n\n\n添加 loading 处理#\n\n 1. 准备数据\n    \n    \n\n 2. el-table上面绑定\n    \n    \n\n 3. 发送请求时添加 loading\n    \n    \n\n\n搜索 和 重置功能#\n\n 1. 注册事件\n    \n    \n\n 2. 绑定处理\n    \n    \n\n\n文章发布&修改 [element-plus - 抽屉]#\n\n\n点击显示抽屉#\n\n 1. 准备数据\n    \n    \n\n 2. 准备抽屉容器\n    \n    \n\n 3. 点击修改布尔值显示抽屉\n    \n    \n\n\n封装抽屉组件 ArticleEdit#\n\n添加 和 编辑，可以共用一个抽屉，所以可以将抽屉封装成一个组件\n\n组件对外暴露一个方法 open, 基于 open 的参数，初始化表单数据，并判断区分是添加 还是 编辑\n\n 1. open({ }) => 添加操作，添加表单初始化无数据\n 2. open({ id: xx, ... }) => 编辑操作，编辑表单初始化需回显\n\n具体实现：\n\n 1. 封装组件 article/components/ArticleEdit.vue\n    \n    \n\n 2. 通过 ref 绑定\n    \n    \n\n 3. 点击调用方法显示弹窗\n    \n    \n\n\n完善抽屉表单结构#\n\n 1. 准备数据\n    \n    \n\n 2. 准备 form 表单结构\n    \n    \n\n 3. 一打开默认重置添加的 form 表单数据\n    \n    \n\n 4. 扩展 下拉菜单 width props\n    \n    \n\n\n上传文件 [element-plus - 文件预览]#\n\n 1. 关闭自动上传，准备结构\n    \n    \n\n 2. 准备数据 和 选择图片的处理逻辑\n    \n    \n\n 3. 样式美化\n    \n    \n\n\n富文本编辑器 [ vue-quill ]#\n\n官网地址：https://vueup.github.io/vue-quill/\n\n 1. 安装包\n    \n    \n\n 2. 注册成局部组件\n    \n    \n\n 3. 页面中使用绑定\n    \n    \n\n 4. 样式美化\n    \n    \n\n\n添加文章功能#\n\n 1. 封装添加接口\n    \n    \n\n 2. 注册点击事件调用\n    \n    \n\n 3. 父组件监听事件，重新渲染\n    \n    \n\n\n添加完成后的内容重置#\n\n\n\n\n编辑文章回显#\n\n如果是编辑操作，一打开抽屉，就需要发送请求，获取数据进行回显\n\n 1. 封装接口，根据 id 获取详情数据\n    \n    \n\n 2. 页面中调用渲染\n    \n    \n\nchatGPT prompt：封装一个函数，基于 axios， 网络图片地址，转 file 对象， 请注意：写中文注释\n\n\n\n\n编辑文章功能#\n\n 1. 封装编辑接口\n    \n    \n\n 2. 提交时调用\n    \n    \n\n\n文章删除#\n\n 1. 封装删除接口\n    \n    \n\n 2. 页面中添加确认框调用\n    \n    \n\n\nChatGPT & Copilot#\n\n\nAI 的认知 & 讲解内容说明#\n\n认知同步：\n\n 1. AI 早已不是新事物 (接受) => 语音识别，人脸识别，无人驾驶，智能机器人... (包括 ChatGPT 也是研发了多年的产物)\n 2. AI 本质是智能工具 (认识) => 人工智能辅助，可以提升效率，但不具备思想意识，无法从零到一取代人类工作\n 3. AI 一定会淘汰掉一部分人 => 逆水行舟，不进则退；学会拥抱变化，尽早上车\n\n两个工具：\n\n 1. ChatGPT 3.5 的使用 (4.0 使用方式一致，回答准确度更高，但付费，且每3小时，有次数限制)\n    \n    1. 正常注册流程 (IP限制，手机号限制)\n    \n    2. 三方整合产品\n       \n       * 谷歌搜索：chatgpt 免费网站列表\n       \n       * https://github.com/LiLittleCat/awesome-free-chatgpt\n\n 2. 工具 Github Copilot 智能生成代码\n\n\nChatGPT 的基本使用 - Prompt 优化#\n\nAI 互动的过程中，容易出现的问题：\n\n * AI未能理解问题的核心要点\n * AI的回答过于宽泛 或 过于具体\n * AI提供了错误的信息或观点\n * AI未能提供有价值的建议或解决方案\n\n在识别了问题所在之后，我们可以尝试以下策略来优化我们的Prompt：\n\n * 明确提问：\n   \n   确保问题表述清晰明确，关键字的准确度，决定了AI 对于需求的理解。\n\n * 细化需求：\n   \n   将问题拆分成多个小问题，可以帮助AI更具针对性地回答，也利于即时纠错。\n\n * 添加背景信息：\n   \n   提供有关问题背景的详细信息，也可以给 AI 预设一个角色，将有助于AI生成更具深度和价值的回答。\n\n * 适当引导：\n   \n   比如：“例如”、“请注意”、“请使用”等，来告诉模型你期望它做什么 或者 不做什么\n\n * 限制范围：\n   \n   通过限定回答的范围和长度，可以引导AI生成更精炼的回答\n\n...\n\n\n案例 - 前端简历#\n\nPrompt 优化前#\n\nPrompt1:\n\n\n\nPrompt 优化后#\n\nPrompt1:\n\n\n\nPrompt2：\n\n\n\nPrompt3：\n\n\n\n\n工具 Github Copilot 智能生成代码的使用#\n\n\n安装步骤#\n\n * 登录 github，试用 Copilot\n * 打开 vscode， 搜索并安装插件 Copilot\n\n\n使用说明#\n\n * 删除键：不接受\n * Tab键：接收\n * Ctrl - enter： 查看更多方案\n\n\n个人中心项目实战 - 基本资料#\n\n\n静态结构 - 校验处理#\n\nchatgpt prompt 提示词参考：\n\n\n\n参考目标代码：\n\n\n\n\n封装接口，更新个人信息#\n\n 1. 封装接口\n    \n    \n\n 2. 页面中校验后，封装调用\n    \n    \n\n\n个人中心项目实战 - 更换头像#\n\n\n静态结构#\n\n\n\n\n选择预览图片#\n\n\n\n\n上传头像#\n\n 1. 封装接口\n    \n    \n\n 2. 调用接口\n    \n    \n\n\n个人中心项目实战 - 重置密码#\n\nchatgpt prompt\n\n\n\n\n静态结构 - 校验处理#\n\n\n\n\n封装接口，更新密码信息#\n\n 1. 封装接口\n    \n    \n\n 2. 页面中调用\n\n","routePath":"/vue/day12-day14-大事件管理系统/大事件管理系统","lang":"","toc":[{"text":"项目页面介绍","id":"项目页面介绍","depth":2,"charIndex":263},{"text":"pnpm 包管理器 - 创建项目","id":"pnpm-包管理器---创建项目","depth":2,"charIndex":281},{"text":"ESLint & prettier 配置代码风格","id":"eslint--prettier-配置代码风格","depth":2,"charIndex":371},{"text":"基于 husky  的代码检查工作流","id":"基于-husky--的代码检查工作流","depth":2,"charIndex":-1},{"text":"调整项目目录","id":"调整项目目录","depth":2,"charIndex":1029},{"text":"VueRouter4 路由代码解析","id":"vuerouter4-路由代码解析","depth":2,"charIndex":1405},{"text":"引入 element-ui 组件库","id":"引入-element-ui-组件库","depth":2,"charIndex":1519},{"text":"Pinia - 构建用户仓库 和 持久化","id":"pinia---构建用户仓库-和-持久化","depth":2,"charIndex":1730},{"text":"Pinia - 配置仓库统一管理","id":"pinia---配置仓库统一管理","depth":2,"charIndex":1926},{"text":"数据交互 - 请求工具设计","id":"数据交互---请求工具设计","depth":2,"charIndex":2220},{"text":"1. 创建 axios 实例","id":"1-创建-axios-实例","depth":3,"charIndex":2239},{"text":"2. 完成 axios 基本配置","id":"2-完成-axios-基本配置","depth":3,"charIndex":2539},{"text":"首页整体路由设计","id":"首页整体路由设计","depth":2,"charIndex":2561},{"text":"登录注册页面 [element-plus 表单 & 表单校验]","id":"登录注册页面-element-plus-表单--表单校验","depth":2,"charIndex":3464},{"text":"注册登录 静态结构 & 基本切换","id":"注册登录-静态结构--基本切换","depth":2,"charIndex":3499},{"text":"注册功能","id":"注册功能","depth":2,"charIndex":3576},{"text":"实现注册校验","id":"实现注册校验","depth":3,"charIndex":3584},{"text":"注册前的预校验","id":"注册前的预校验","depth":3,"charIndex":3841},{"text":"封装 api 实现注册功能","id":"封装-api-实现注册功能","depth":3,"charIndex":3929},{"text":"登录功能","id":"登录功能","depth":2,"charIndex":4079},{"text":"实现登录校验","id":"实现登录校验","depth":3,"charIndex":4087},{"text":"登录前的预校验 & 登录成功","id":"登录前的预校验--登录成功","depth":3,"charIndex":4390},{"text":"首页 layout 架子 [element-plus 菜单]","id":"首页-layout-架子-element-plus-菜单","depth":2,"charIndex":4758},{"text":"基本架子拆解","id":"基本架子拆解","depth":2,"charIndex":4792},{"text":"登录访问拦截","id":"登录访问拦截","depth":2,"charIndex":4967},{"text":"用户基本信息获取&渲染","id":"用户基本信息获取渲染","depth":2,"charIndex":5017},{"text":"退出功能 [element-plus 确认框]","id":"退出功能-element-plus-确认框","depth":2,"charIndex":5169},{"text":"文章分类页面 - [element-plus 表格]","id":"文章分类页面---element-plus-表格","depth":2,"charIndex":5286},{"text":"基本架子 - PageContainer","id":"基本架子---pagecontainer","depth":2,"charIndex":5316},{"text":"文章分类渲染","id":"文章分类渲染","depth":2,"charIndex":5573},{"text":"封装API - 请求获取表格数据","id":"封装api---请求获取表格数据","depth":3,"charIndex":5583},{"text":"el-table 表格动态渲染","id":"el-table-表格动态渲染","depth":3,"charIndex":5678},{"text":"el-table 表格 loading 效果","id":"el-table-表格-loading-效果","depth":3,"charIndex":5699},{"text":"文章分类添加编辑 [element-plus 弹层]","id":"文章分类添加编辑-element-plus-弹层","depth":2,"charIndex":5787},{"text":"点击显示弹层","id":"点击显示弹层","depth":3,"charIndex":5817},{"text":"封装弹层组件 ChannelEdit","id":"封装弹层组件-channeledit","depth":3,"charIndex":5867},{"text":"准备弹层表单","id":"准备弹层表单","depth":3,"charIndex":6167},{"text":"确认提交","id":"确认提交","depth":3,"charIndex":6299},{"text":"文章分类删除","id":"文章分类删除","depth":2,"charIndex":6449},{"text":"文章管理页面 - [element-plus 强化]","id":"文章管理页面---element-plus-强化","depth":2,"charIndex":6530},{"text":"文章列表渲染","id":"文章列表渲染","depth":2,"charIndex":6560},{"text":"基本架子搭建","id":"基本架子搭建","depth":3,"charIndex":6570},{"text":"中英国际化处理","id":"中英国际化处理","depth":3,"charIndex":6640},{"text":"文章分类选择","id":"文章分类选择","depth":3,"charIndex":6698},{"text":"封装 API 接口，请求渲染","id":"封装-api-接口请求渲染","depth":3,"charIndex":6930},{"text":"分页渲染 [element-plus 分页]","id":"分页渲染-element-plus-分页","depth":3,"charIndex":7095},{"text":"添加 loading 处理","id":"添加-loading-处理","depth":3,"charIndex":7165},{"text":"搜索 和 重置功能","id":"搜索-和-重置功能","depth":3,"charIndex":7261},{"text":"文章发布&修改 [element-plus - 抽屉]","id":"文章发布修改-element-plus---抽屉","depth":2,"charIndex":7314},{"text":"点击显示抽屉","id":"点击显示抽屉","depth":3,"charIndex":7345},{"text":"封装抽屉组件 ArticleEdit","id":"封装抽屉组件-articleedit","depth":3,"charIndex":7424},{"text":"完善抽屉表单结构","id":"完善抽屉表单结构","depth":3,"charIndex":7724},{"text":"上传文件 [element-plus - 文件预览]","id":"上传文件-element-plus---文件预览","depth":3,"charIndex":7855},{"text":"富文本编辑器 [ vue-quill ]","id":"富文本编辑器--vue-quill-","depth":3,"charIndex":7964},{"text":"添加文章功能","id":"添加文章功能","depth":3,"charIndex":8114},{"text":"添加完成后的内容重置","id":"添加完成后的内容重置","depth":3,"charIndex":8198},{"text":"编辑文章回显","id":"编辑文章回显","depth":3,"charIndex":8214},{"text":"编辑文章功能","id":"编辑文章功能","depth":3,"charIndex":8375},{"text":"文章删除","id":"文章删除","depth":2,"charIndex":8428},{"text":"ChatGPT & Copilot","id":"chatgpt--copilot","depth":2,"charIndex":8484},{"text":"AI 的认知 & 讲解内容说明","id":"ai-的认知--讲解内容说明","depth":2,"charIndex":8505},{"text":"ChatGPT 的基本使用 - Prompt 优化","id":"chatgpt-的基本使用---prompt-优化","depth":2,"charIndex":8957},{"text":"案例 - 前端简历","id":"案例---前端简历","depth":3,"charIndex":9399},{"text":"Prompt 优化前","id":"prompt-优化前","depth":4,"charIndex":9411},{"text":"Prompt 优化后","id":"prompt-优化后","depth":4,"charIndex":9436},{"text":"工具 Github Copilot 智能生成代码的使用","id":"工具-github-copilot-智能生成代码的使用","depth":2,"charIndex":9486},{"text":"安装步骤","id":"安装步骤","depth":3,"charIndex":9517},{"text":"使用说明","id":"使用说明","depth":3,"charIndex":9580},{"text":"个人中心项目实战 - 基本资料","id":"个人中心项目实战---基本资料","depth":2,"charIndex":9635},{"text":"静态结构 - 校验处理","id":"静态结构---校验处理","depth":3,"charIndex":9654},{"text":"封装接口，更新个人信息","id":"封装接口更新个人信息","depth":3,"charIndex":9705},{"text":"个人中心项目实战 - 更换头像","id":"个人中心项目实战---更换头像","depth":2,"charIndex":9767},{"text":"静态结构","id":"静态结构","depth":3,"charIndex":9786},{"text":"选择预览图片","id":"选择预览图片","depth":3,"charIndex":9796},{"text":"上传头像","id":"上传头像","depth":3,"charIndex":9808},{"text":"个人中心项目实战 - 重置密码","id":"个人中心项目实战---重置密码","depth":2,"charIndex":9856},{"text":"静态结构 - 校验处理","id":"静态结构---校验处理-1","depth":3,"charIndex":9893},{"text":"封装接口，更新密码信息","id":"封装接口更新密码信息","depth":3,"charIndex":9910}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"MarkDown入门教程","content":"Hello World!","routePath":"/vue/","lang":"","toc":[{"text":"开始","id":"开始","depth":2,"charIndex":-1},{"text":"一、准备工作","id":"一准备工作","depth":3,"charIndex":-1},{"text":"二、基本语法","id":"二基本语法","depth":3,"charIndex":-1},{"text":"三、其他操作","id":"三其他操作","depth":3,"charIndex":-1},{"text":"四、导出为PDF","id":"四导出为pdf","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""}]